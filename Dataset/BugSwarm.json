[
    {
        "ID": 32438378016.0,
        "Patch": "96,12 +96,13 @@ public final class MethodSymbolComputer\n    MethodSymbol methodSymbol = createMethodSymbol(\n      startNode,\n      stopNode,\n      declaration.FUNCTION_KEYWORD().getSymbol(),\n      declaration.subName().getStart(),\n      declaration.paramList(),\n      true,\n      declaration.EXPORT_KEYWORD() != null,\n      getCompilerDirective(declaration.compilerDirective()),\n      getAnnotations(declaration.annotation()));\n      createAnnotations(declaration.annotation()));\n    methods.add(methodSymbol);\n@@ -130,12 +131,13 @@ public final class MethodSymbolComputer\n    MethodSymbol methodSymbol = createMethodSymbol(\n      startNode,\n      stopNode,\n      declaration.PROCEDURE_KEYWORD().getSymbol(),\n      declaration.subName().getStart(),\n      declaration.paramList(),\n      false,\n      declaration.EXPORT_KEYWORD() != null,\n      getCompilerDirective(declaration.compilerDirective()),\n      getAnnotations(declaration.annotation())\n      createAnnotations(declaration.annotation())\n    );\n    methods.add(methodSymbol);\n@@ -190,6 +192,7 @@ public final class MethodSymbolComputer\n  private MethodSymbol createMethodSymbol(\n    TerminalNode startNode,\n    TerminalNode stopNode,\n    Token startOfMethod,\n    Token subName,\n    BSLParser.ParamListContext paramList,\n    boolean function,\n@@ -197,7 +200,8 @@ public final class MethodSymbolComputer\n    Optional<CompilerDirectiveKind> compilerDirective,\n    List<Annotation> annotations\n  ) {\n    Optional<MethodDescription> description = createDescription(startNode.getSymbol());\n    Optional<MethodDescription> description = createDescription(startOfMethod)\n      .or(() -> createDescription(startNode.getSymbol()));\n    boolean deprecated = description\n      .map(MethodDescription::isDeprecated)\n      .orElse(false);\n@@ -244,7 +248,7 @@ public final class MethodSymbolComputer\n          .range(getParameterRange(param))\n          .description(getParameterDescription(parameterName, description))\n          .build();\n      }).collect(Collectors.toList());\n      }).toList();\n  }\n  private static ParameterDefinition.DefaultValue getDefaultValue(BSLParser.ParamContext param) {\n@@ -318,10 +322,10 @@ public final class MethodSymbolComputer\n  }\n  private static List<Annotation> getAnnotations(List<? extends BSLParser.AnnotationContext> annotationContext) {\n    return annotationContext.stream()\n  private static List<Annotation> createAnnotations(List<? extends BSLParser.AnnotationContext> annotationContexts) {\n    return annotationContexts.stream()\n      .map(MethodSymbolComputer::createAnnotation)\n      .collect(Collectors.toList());\n      .toList();\n  }\n  private static Annotation createAnnotation(BSLParser.AnnotationContext annotation) {\n@@ -342,7 +346,7 @@ public final class MethodSymbolComputer\n    return annotationParamsContext.annotationParam().stream()\n      .map(MethodSymbolComputer::getAnnotationParam)\n      .collect(Collectors.toList());\n      .toList();\n  }\n  private static AnnotationParameterDefinition getAnnotationParam(BSLParser.AnnotationParamContext o) {",
        "Label": "NPE_Fix"
    },
    {
        "ID": 32438378366.0,
        "Patch": "96,12 +96,13 @@ public final class MethodSymbolComputer\n    MethodSymbol methodSymbol = createMethodSymbol(\n      startNode,\n      stopNode,\n      declaration.FUNCTION_KEYWORD().getSymbol(),\n      declaration.subName().getStart(),\n      declaration.paramList(),\n      true,\n      declaration.EXPORT_KEYWORD() != null,\n      getCompilerDirective(declaration.compilerDirective()),\n      getAnnotations(declaration.annotation()));\n      createAnnotations(declaration.annotation()));\n    methods.add(methodSymbol);\n@@ -130,12 +131,13 @@ public final class MethodSymbolComputer\n    MethodSymbol methodSymbol = createMethodSymbol(\n      startNode,\n      stopNode,\n      declaration.PROCEDURE_KEYWORD().getSymbol(),\n      declaration.subName().getStart(),\n      declaration.paramList(),\n      false,\n      declaration.EXPORT_KEYWORD() != null,\n      getCompilerDirective(declaration.compilerDirective()),\n      getAnnotations(declaration.annotation())\n      createAnnotations(declaration.annotation())\n    );\n    methods.add(methodSymbol);\n@@ -190,6 +192,7 @@ public final class MethodSymbolComputer\n  private MethodSymbol createMethodSymbol(\n    TerminalNode startNode,\n    TerminalNode stopNode,\n    Token startOfMethod,\n    Token subName,\n    BSLParser.ParamListContext paramList,\n    boolean function,\n@@ -197,7 +200,8 @@ public final class MethodSymbolComputer\n    Optional<CompilerDirectiveKind> compilerDirective,\n    List<Annotation> annotations\n  ) {\n    Optional<MethodDescription> description = createDescription(startNode.getSymbol());\n    Optional<MethodDescription> description = createDescription(startOfMethod)\n      .or(() -> createDescription(startNode.getSymbol()));\n    boolean deprecated = description\n      .map(MethodDescription::isDeprecated)\n      .orElse(false);\n@@ -244,7 +248,7 @@ public final class MethodSymbolComputer\n          .range(getParameterRange(param))\n          .description(getParameterDescription(parameterName, description))\n          .build();\n      }).collect(Collectors.toList());\n      }).toList();\n  }\n  private static ParameterDefinition.DefaultValue getDefaultValue(BSLParser.ParamContext param) {\n@@ -318,10 +322,10 @@ public final class MethodSymbolComputer\n  }\n  private static List<Annotation> getAnnotations(List<? extends BSLParser.AnnotationContext> annotationContext) {\n    return annotationContext.stream()\n  private static List<Annotation> createAnnotations(List<? extends BSLParser.AnnotationContext> annotationContexts) {\n    return annotationContexts.stream()\n      .map(MethodSymbolComputer::createAnnotation)\n      .collect(Collectors.toList());\n      .toList();\n  }\n  private static Annotation createAnnotation(BSLParser.AnnotationContext annotation) {\n@@ -342,7 +346,7 @@ public final class MethodSymbolComputer\n    return annotationParamsContext.annotationParam().stream()\n      .map(MethodSymbolComputer::getAnnotationParam)\n      .collect(Collectors.toList());\n      .toList();\n  }\n  private static AnnotationParameterDefinition getAnnotationParam(BSLParser.AnnotationParamContext o) {",
        "Label": "NPE_Fix"
    },
    {
        "ID": 32438380396.0,
        "Patch": "public final class MethodSymbolComputer\n    MethodSymbol methodSymbol = createMethodSymbol(\n      startNode,\n      stopNode,\n      declaration.FUNCTION_KEYWORD().getSymbol(),\n      declaration.subName().getStart(),\n      declaration.paramList(),\n      true,\n      declaration.EXPORT_KEYWORD() != null,\n      getCompilerDirective(declaration.compilerDirective()),\n      getAnnotations(declaration.annotation()));\n      createAnnotations(declaration.annotation()));\n    methods.add(methodSymbol);\n@@ -130,12 +131,13 @@ public final class MethodSymbolComputer\n    MethodSymbol methodSymbol = createMethodSymbol(\n      startNode,\n      stopNode,\n      declaration.PROCEDURE_KEYWORD().getSymbol(),\n      declaration.subName().getStart(),\n      declaration.paramList(),\n      false,\n      declaration.EXPORT_KEYWORD() != null,\n      getCompilerDirective(declaration.compilerDirective()),\n      getAnnotations(declaration.annotation())\n      createAnnotations(declaration.annotation())\n    );\n    methods.add(methodSymbol);\n@@ -190,6 +192,7 @@ public final class MethodSymbolComputer\n  private MethodSymbol createMethodSymbol(\n    TerminalNode startNode,\n    TerminalNode stopNode,\n    Token startOfMethod,\n    Token subName,\n    BSLParser.ParamListContext paramList,\n    boolean function,\n@@ -197,7 +200,8 @@ public final class MethodSymbolComputer\n    Optional<CompilerDirectiveKind> compilerDirective,\n    List<Annotation> annotations\n  ) {\n    Optional<MethodDescription> description = createDescription(startNode.getSymbol());\n    Optional<MethodDescription> description = createDescription(startOfMethod)\n      .or(() -> createDescription(startNode.getSymbol()));\n    boolean deprecated = description\n      .map(MethodDescription::isDeprecated)\n      .orElse(false);\n@@ -244,7 +248,7 @@ public final class MethodSymbolComputer\n          .range(getParameterRange(param))\n          .description(getParameterDescription(parameterName, description))\n          .build();\n      }).collect(Collectors.toList());\n      }).toList();\n  }\n  private static ParameterDefinition.DefaultValue getDefaultValue(BSLParser.ParamContext param) {\n@@ -318,10 +322,10 @@ public final class MethodSymbolComputer\n  }\n  private static List<Annotation> getAnnotations(List<? extends BSLParser.AnnotationContext> annotationContext) {\n    return annotationContext.stream()\n  private static List<Annotation> createAnnotations(List<? extends BSLParser.AnnotationContext> annotationContexts) {\n    return annotationContexts.stream()\n      .map(MethodSymbolComputer::createAnnotation)\n      .collect(Collectors.toList());\n      .toList();\n  }\n  private static Annotation createAnnotation(BSLParser.AnnotationContext annotation) {\n@@ -342,7 +346,7 @@ public final class MethodSymbolComputer\n    return annotationParamsContext.annotationParam().stream()\n      .map(MethodSymbolComputer::getAnnotationParam)\n      .collect(Collectors.toList());\n      .toList();\n  }\n  private static AnnotationParameterDefinition getAnnotationParam(BSLParser.AnnotationParamContext o) {",
        "Label": "NPE_Fix"
    },
    {
        "ID": 36920124807.0,
        "Patch": "54,7 +54,7 @@ public class AnnotationsDeserializer extends JsonDeserializer<Set<String>> {\n    Set<String> annotationsSet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n    var objectMapper = (ObjectMapper) p.getCodec();\n    objectMapper.readerForUpdating(annotationsSet).readValue(p);\n    objectMapper.readerForUpdating(annotationsSet).readValue(annotations);\n    return annotationsSet;\n  }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 36920124236.0,
        "Patch": "54,7 +54,7 @@ public class AnnotationsDeserializer extends JsonDeserializer<Set<String>> {\n    Set<String> annotationsSet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n    var objectMapper = (ObjectMapper) p.getCodec();\n    objectMapper.readerForUpdating(annotationsSet).readValue(p);\n    objectMapper.readerForUpdating(annotationsSet).readValue(annotations);\n    return annotationsSet;\n  }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 36920124443.0,
        "Patch": "54,7 +54,7 @@ public class AnnotationsDeserializer extends JsonDeserializer<Set<String>> {\n    Set<String> annotationsSet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n    var objectMapper = (ObjectMapper) p.getCodec();\n    objectMapper.readerForUpdating(annotationsSet).readValue(p);\n    objectMapper.readerForUpdating(annotationsSet).readValue(annotations);\n    return annotationsSet;\n  }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 36920124522.0,
        "Patch": "public class AnnotationsDeserializer extends JsonDeserializer<Set<String>> {\n    Set<String> annotationsSet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n    var objectMapper = (ObjectMapper) p.getCodec();\n    objectMapper.readerForUpdating(annotationsSet).readValue(p);\n    objectMapper.readerForUpdating(annotationsSet).readValue(annotations);\n    return annotationsSet;\n  }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 36920124807.0,
        "Patch": "src/main/java/com/github/_1c_syntax/bsl/languageserver/configuration/databind/AnnotationsDeserializer.java\n@@ -54,7 +54,7 @@ public class AnnotationsDeserializer extends JsonDeserializer<Set<String>> {\n    Set<String> annotationsSet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n    var objectMapper = (ObjectMapper) p.getCodec();\n    objectMapper.readerForUpdating(annotationsSet).readValue(p);\n    objectMapper.readerForUpdating(annotationsSet).readValue(annotations);\n    return annotationsSet;\n  }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 36920125049.0,
        "Patch": "1, -1•src/main/java/com/github/_1c_syntax/bsl/languageserver/configuration/databind/AnnotationsDeserializer.java\n@@ -54,7 +54,7 @@ public class AnnotationsDeserializer extends JsonDeserializer<Set<String>> {\n    Set<String> annotationsSet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n    var objectMapper = (ObjectMapper) p.getCodec();\n    objectMapper.readerForUpdating(annotationsSet).readValue(p);\n    objectMapper.readerForUpdating(annotationsSet).readValue(annotations);\n    return annotationsSet;\n  }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 336166192.0,
        "Patch": "208,10 +211,10 @@ public abstract class OnDeployScriptBase implements OnDeployScript {\n     * @param resourceType The new sling:resourceType to be used.\n     */\n    protected void updateResourceType(Node node, String resourceType) throws RepositoryException {\n        String currentResourceType = node.getProperty(\"sling:resourceType\").getString();\n        String currentResourceType = node.getProperty(SLING_RESOURCE_TYPE).getString();\n        if (!resourceType.equals(currentResourceType)) {\n            logger.info(\"Updating node at {} to resource type: {}\", node.getPath(), resourceType);\n            node.setProperty(\"sling:resourceType\", resourceType);\n            node.setProperty(SLING_RESOURCE_TYPE, resourceType);\n        } else {\n            logger.info(\"Node at {} is already resource type: {}\", node.getPath(), resourceType);\n        }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 336166196.0,
        "Patch": "208,10 +211,10 @@ public abstract class OnDeployScriptBase implements OnDeployScript {\n     * @param resourceType The new sling:resourceType to be used.\n     */\n    protected void updateResourceType(Node node, String resourceType) throws RepositoryException {\n        String currentResourceType = node.getProperty(\"sling:resourceType\").getString();\n        String currentResourceType = node.getProperty(SLING_RESOURCE_TYPE).getString();\n        if (!resourceType.equals(currentResourceType)) {\n            logger.info(\"Updating node at {} to resource type: {}\", node.getPath(), resourceType);\n            node.setProperty(\"sling:resourceType\", resourceType);\n            node.setProperty(SLING_RESOURCE_TYPE, resourceType);\n        } else {\n            logger.info(\"Node at {} is already resource type: {}\", node.getPath(), resourceType);\n        }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 369395857.0,
        "Patch": "8,6 +8,8 @@ The format is based on [Keep a Changelog](http://keepachangelog.com/)\n## [Unreleased]\n[Unreleased]: https://github.com/Adobe-Consulting-Services/acs-aem-commons/compare/acs-aem-commons-3.15.0...HEAD\n### Fixed\n- #1335 - MCP Error handling and user experience are overhauled and the overall experience is improved\n## [3.15.0] - 2018-04-13\n+15, -4•bundle/src/main/java/com/adobe/acs/commons/fam/impl/ActionManagerImpl.java\n@@ -157,13 +157,24 @@ class ActionManagerImpl extends CancelHandler implements ActionManager, Serializ\n                if (!closesResolver) {\n                    logCompletetion();\n                }\n            } catch (Error e) {\n                // These are very fatal errors but we should log them if we can\n                LOG.error(\"Fatal uncaught error in action \" + getName(), e);\n                if (!closesResolver) {\n                    logError(new RuntimeException(e));\n                }\n                throw e;\n            } catch (Exception t) {\n                // Less fatal errors, but still need to explicitly catch them\n                LOG.error(\"Error in action \" + getName(), t);\n                if (!closesResolver) {\n                    logError(t);\n                }\n            } catch (Throwable t) {\n                // There are some slippery runtime errors (unchecked) which slip through the cracks\n                LOG.error(\"Fatal uncaught error in action \" + getName(), t);\n                if (!closesResolver) {\n                    logError(t instanceof Exception ? (Exception) t : new RuntimeException(t));\n                }\n                if (t instanceof Error) {\n                    throw (Error) t;\n                    logError(new RuntimeException(t));\n                }\n            }\n        }, this);\n+3, -3•bundle/src/main/java/com/adobe/acs/commons/mcp/impl/ProcessInstanceImpl.java\n@@ -248,8 +248,8 @@ public class ProcessInstanceImpl implements ProcessInstance, Serializable {\n                rr.commit();\n            }\n            rr.refresh();\n            ActionManager manager = getActionManagerFactory().createTaskManager(\"Record errors\", rr, 1);\n            ActionBatch batch = new ActionBatch(manager, 50);\n            ActionManager errorManager = getActionManagerFactory().createTaskManager(\"Record errors\", rr, 1);\n            ActionBatch batch = new ActionBatch(errorManager, 50);\n            for (int i = 0; i < failures.size(); i++) {\n                String errPath = errFolder + \"/err\" + i;\n                Failure failure = failures.get(i);\n@@ -260,7 +260,7 @@ public class ProcessInstanceImpl implements ProcessInstance, Serializable {\n                });\n            }\n            batch.commitBatch();\n        } catch (RepositoryException | PersistenceException | LoginException ex) {\n        } catch (RepositoryException | PersistenceException | LoginException | NullPointerException ex) {\n            LOG.error(\"Unable to record errors\", ex);\n        }\n    }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 369395858.0,
        "Patch": "The format is based on [Keep a Changelog](http://keepachangelog.com/)\n## [Unreleased]\n[Unreleased]: https://github.com/Adobe-Consulting-Services/acs-aem-commons/compare/acs-aem-commons-3.15.0...HEAD\n### Fixed\n- #1335 - MCP Error handling and user experience are overhauled and the overall experience is improved",
        "Label": "NPE_Fix"
    },
    {
        "ID": 369395859.0,
        "Patch": "157,13 +157,24 @@ class ActionManagerImpl extends CancelHandler implements ActionManager, Serializ\n                if (!closesResolver) {\n                    logCompletetion();\n                }\n            } catch (Error e) {\n                // These are very fatal errors but we should log them if we can\n                LOG.error(\"Fatal uncaught error in action \" + getName(), e);\n                if (!closesResolver) {\n                    logError(new RuntimeException(e));\n                }\n                throw e;\n            } catch (Exception t) {\n                // Less fatal errors, but still need to explicitly catch them\n                LOG.error(\"Error in action \" + getName(), t);\n                if (!closesResolver) {\n                    logError(t);\n                }\n            } catch (Throwable t) {\n                // There are some slippery runtime errors (unchecked) which slip through the cracks\n                LOG.error(\"Fatal uncaught error in action \" + getName(), t);\n                if (!closesResolver) {\n                    logError(t instanceof Exception ? (Exception) t : new RuntimeException(t));\n                }\n                if (t instanceof Error) {\n                    throw (Error) t;\n                    logError(new RuntimeException(t));\n                }\n            }\n        }, this);",
        "Label": "NPE_Fix"
    },
    {
        "ID": 369395860.0,
        "Patch": "public class ProcessInstanceImpl implements ProcessInstance, Serializable {\n                rr.commit();\n            }\n            rr.refresh();\n            ActionManager manager = getActionManagerFactory().createTaskManager(\"Record errors\", rr, 1);\n            ActionBatch batch = new ActionBatch(manager, 50);\n            ActionManager errorManager = getActionManagerFactory().createTaskManager(\"Record errors\", rr, 1);\n            ActionBatch batch = new ActionBatch(errorManager, 50);\n            for (int i = 0; i < failures.size(); i++) {\n                String errPath = errFolder + \"/err\" + i;\n                Failure failure = failures.get(i);\n@@ -260,7 +260,7 @@ public class ProcessInstanceImpl implements ProcessInstance, Serializable {\n                });\n            }\n            batch.commitBatch();\n        } catch (RepositoryException | PersistenceException | LoginException ex) {\n        } catch (RepositoryException | PersistenceException | LoginException | NullPointerException ex) {\n            LOG.error(\"Unable to record errors\", ex);\n        }\n    }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 374231969.0,
        "Patch": "299,15 +299,15 @@ public class UrlAssetImport extends AssetIngestor {\n        FileOrRendition file = new FileOrRendition(this::getHttpClient, name, source, folder, assetData);\n        file.setAsRenditionOfImage(\n                assetData.get(RENDITION_NAME).toString(),\n                assetData.get(ORIGINAL_FILE_NAME).toString()\n                assetData.get(RENDITION_NAME) == null ? null : assetData.get(RENDITION_NAME).toString(),\n                assetData.get(ORIGINAL_FILE_NAME) == null ? null : assetData.get(ORIGINAL_FILE_NAME).toString()\n        );\n        return file;\n    }\n    private String getTargetFolder(Map<String, CompositeVariant> assetData) {\n        String target = assetData.get(TARGET_FOLDER).toString();\n        String target = assetData.get(TARGET_FOLDER) == null ? null : assetData.get(TARGET_FOLDER).toString();\n        if (target == null || target.isEmpty()) {\n            return UNKNOWN_TARGET_FOLDER;\n        } else if (!target.startsWith(CONTENT_BASE)) {\n+1, -1•bundle/src/main/java/com/adobe/acs/commons/mcp/util/Spreadsheet.java\n@@ -68,7 +68,7 @@ public class Spreadsheet {\n    public Spreadsheet(boolean convertHeaderNames, String... headerArray) {\n        this.enableHeaderNameConversion = convertHeaderNames;\n        headerTypes = Arrays.stream(headerArray).collect(Collectors.toMap(this::convertHeaderName, this::detectTypeFromName));\n        headerRow = new ArrayList(headerTypes.keySet());\n        headerRow = Arrays.asList(headerArray);\n        requiredColumns = Collections.EMPTY_LIST;\n        dataRows = new ArrayList<>();\n        delimiters = new HashMap<>();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 374231970.0,
        "Patch": "public class UrlAssetImport extends AssetIngestor {\n        FileOrRendition file = new FileOrRendition(this::getHttpClient, name, source, folder, assetData);\n        file.setAsRenditionOfImage(\n                assetData.get(RENDITION_NAME).toString(),\n                assetData.get(ORIGINAL_FILE_NAME).toString()\n                assetData.get(RENDITION_NAME) == null ? null : assetData.get(RENDITION_NAME).toString(),\n                assetData.get(ORIGINAL_FILE_NAME) == null ? null : assetData.get(ORIGINAL_FILE_NAME).toString()\n        );\n        return file;\n    }\n    private String getTargetFolder(Map<String, CompositeVariant> assetData) {\n        String target = assetData.get(TARGET_FOLDER).toString();\n        String target = assetData.get(TARGET_FOLDER) == null ? null : assetData.get(TARGET_FOLDER).toString();\n        if (target == null || target.isEmpty()) {\n            return UNKNOWN_TARGET_FOLDER;\n        } else if (!target.startsWith(CONTENT_BASE)) {\n+1, -1•bundle/src/main/java/com/adobe/acs/commons/mcp/util/Spreadsheet.java\n@@ -68,7 +68,7 @@ public class Spreadsheet {\n    public Spreadsheet(boolean convertHeaderNames, String... headerArray) {\n        this.enableHeaderNameConversion = convertHeaderNames;\n        headerTypes = Arrays.stream(headerArray).collect(Collectors.toMap(this::convertHeaderName, this::detectTypeFromName));\n        headerRow = new ArrayList(headerTypes.keySet());\n        headerRow = Arrays.asList(headerArray);\n        requiredColumns = Collections.EMPTY_LIST;\n        dataRows = new ArrayList<>();\n        delimiters = new HashMap<>();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 374231971.0,
        "Patch": "bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/asset/UrlAssetImport.java\n@@ -299,15 +299,15 @@ public class UrlAssetImport extends AssetIngestor {\n        FileOrRendition file = new FileOrRendition(this::getHttpClient, name, source, folder, assetData);\n        file.setAsRenditionOfImage(\n                assetData.get(RENDITION_NAME).toString(),\n                assetData.get(ORIGINAL_FILE_NAME).toString()\n                assetData.get(RENDITION_NAME) == null ? null : assetData.get(RENDITION_NAME).toString(),\n                assetData.get(ORIGINAL_FILE_NAME) == null ? null : assetData.get(ORIGINAL_FILE_NAME).toString()\n        );\n        return file;\n    }\n    private String getTargetFolder(Map<String, CompositeVariant> assetData) {\n        String target = assetData.get(TARGET_FOLDER).toString();\n        String target = assetData.get(TARGET_FOLDER) == null ? null : assetData.get(TARGET_FOLDER).toString();\n        if (target == null || target.isEmpty()) {\n            return UNKNOWN_TARGET_FOLDER;\n        } else if (!target.startsWith(CONTENT_BASE)) {\n+1, -1•bundle/src/main/java/com/adobe/acs/commons/mcp/util/Spreadsheet.java\n@@ -68,7 +68,7 @@ public class Spreadsheet {\n    public Spreadsheet(boolean convertHeaderNames, String... headerArray) {\n        this.enableHeaderNameConversion = convertHeaderNames;\n        headerTypes = Arrays.stream(headerArray).collect(Collectors.toMap(this::convertHeaderName, this::detectTypeFromName));\n        headerRow = new ArrayList(headerTypes.keySet());\n        headerRow = Arrays.asList(headerArray);\n        requiredColumns = Collections.EMPTY_LIST;\n        dataRows = new ArrayList<>();\n        delimiters = new HashMap<>();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 374231972.0,
        "Patch": "src/main/java/com/adobe/acs/commons/mcp/impl/processes/asset/UrlAssetImport.java\n@@ -299,15 +299,15 @@ public class UrlAssetImport extends AssetIngestor {\n        FileOrRendition file = new FileOrRendition(this::getHttpClient, name, source, folder, assetData);\n        file.setAsRenditionOfImage(\n                assetData.get(RENDITION_NAME).toString(),\n                assetData.get(ORIGINAL_FILE_NAME).toString()\n                assetData.get(RENDITION_NAME) == null ? null : assetData.get(RENDITION_NAME).toString(),\n                assetData.get(ORIGINAL_FILE_NAME) == null ? null : assetData.get(ORIGINAL_FILE_NAME).toString()\n        );\n        return file;\n    }\n    private String getTargetFolder(Map<String, CompositeVariant> assetData) {\n        String target = assetData.get(TARGET_FOLDER).toString();\n        String target = assetData.get(TARGET_FOLDER) == null ? null : assetData.get(TARGET_FOLDER).toString();\n        if (target == null || target.isEmpty()) {\n            return UNKNOWN_TARGET_FOLDER;\n        } else if (!target.startsWith(CONTENT_BASE)) {\n+1, -1•bundle/src/main/java/com/adobe/acs/commons/mcp/util/Spreadsheet.java\n@@ -68,7 +68,7 @@ public class Spreadsheet {\n    public Spreadsheet(boolean convertHeaderNames, String... headerArray) {\n        this.enableHeaderNameConversion = convertHeaderNames;\n        headerTypes = Arrays.stream(headerArray).collect(Collectors.toMap(this::convertHeaderName, this::detectTypeFromName));\n        headerRow = new ArrayList(headerTypes.keySet());\n        headerRow = Arrays.asList(headerArray);\n        requiredColumns = Collections.EMPTY_LIST;\n        dataRows = new ArrayList<>();\n        delimiters = new HashMap<>();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 374231978.0,
        "Patch": "public class UrlAssetImport extends AssetIngestor {\n        FileOrRendition file = new FileOrRendition(this::getHttpClient, name, source, folder, assetData);\n        file.setAsRenditionOfImage(\n                assetData.get(RENDITION_NAME).toString(),\n                assetData.get(ORIGINAL_FILE_NAME).toString()\n                assetData.get(RENDITION_NAME) == null ? null : assetData.get(RENDITION_NAME).toString(),\n                assetData.get(ORIGINAL_FILE_NAME) == null ? null : assetData.get(ORIGINAL_FILE_NAME).toString()\n        );\n        return file;\n    }\n    private String getTargetFolder(Map<String, CompositeVariant> assetData) {\n        String target = assetData.get(TARGET_FOLDER).toString();\n        String target = assetData.get(TARGET_FOLDER) == null ? null : assetData.get(TARGET_FOLDER).toString();\n        if (target == null || target.isEmpty()) {\n            return UNKNOWN_TARGET_FOLDER;\n        } else if (!target.startsWith(CONTENT_BASE)) {\n+1, -1•bundle/src/main/java/com/adobe/acs/commons/mcp/util/Spreadsheet.java\n@@ -68,7 +68,7 @@ public class Spreadsheet {\n    public Spreadsheet(boolean convertHeaderNames, String... headerArray) {\n        this.enableHeaderNameConversion = convertHeaderNames;\n        headerTypes = Arrays.stream(headerArray).collect(Collectors.toMap(this::convertHeaderName, this::detectTypeFromName));\n        headerRow = new ArrayList(headerTypes.keySet());\n        headerRow = Arrays.asList(headerArray);\n        requiredColumns = Collections.EMPTY_LIST;\n        dataRows = new ArrayList<>();\n        delimiters = new HashMap<>();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 374231979.0,
        "Patch": "299,15 +299,15 @@ public class UrlAssetImport extends AssetIngestor {\n        FileOrRendition file = new FileOrRendition(this::getHttpClient, name, source, folder, assetData);\n        file.setAsRenditionOfImage(\n                assetData.get(RENDITION_NAME).toString(),\n                assetData.get(ORIGINAL_FILE_NAME).toString()\n                assetData.get(RENDITION_NAME) == null ? null : assetData.get(RENDITION_NAME).toString(),\n                assetData.get(ORIGINAL_FILE_NAME) == null ? null : assetData.get(ORIGINAL_FILE_NAME).toString()\n        );\n        return file;\n    }\n    private String getTargetFolder(Map<String, CompositeVariant> assetData) {\n        String target = assetData.get(TARGET_FOLDER).toString();\n        String target = assetData.get(TARGET_FOLDER) == null ? null : assetData.get(TARGET_FOLDER).toString();\n        if (target == null || target.isEmpty()) {\n            return UNKNOWN_TARGET_FOLDER;\n        } else if (!target.startsWith(CONTENT_BASE)) {\n+1, -1•bundle/src/main/java/com/adobe/acs/commons/mcp/util/Spreadsheet.java\n@@ -68,7 +68,7 @@ public class Spreadsheet {\n    public Spreadsheet(boolean convertHeaderNames, String... headerArray) {\n        this.enableHeaderNameConversion = convertHeaderNames;\n        headerTypes = Arrays.stream(headerArray).collect(Collectors.toMap(this::convertHeaderName, this::detectTypeFromName));\n        headerRow = new ArrayList(headerTypes.keySet());\n        headerRow = Arrays.asList(headerArray);\n        requiredColumns = Collections.EMPTY_LIST;\n        dataRows = new ArrayList<>();\n        delimiters = new HashMap<>();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 374231980.0,
        "Patch": "bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/asset/UrlAssetImport.java\n@@ -299,15 +299,15 @@ public class UrlAssetImport extends AssetIngestor {\n        FileOrRendition file = new FileOrRendition(this::getHttpClient, name, source, folder, assetData);\n        file.setAsRenditionOfImage(\n                assetData.get(RENDITION_NAME).toString(),\n                assetData.get(ORIGINAL_FILE_NAME).toString()\n                assetData.get(RENDITION_NAME) == null ? null : assetData.get(RENDITION_NAME).toString(),\n                assetData.get(ORIGINAL_FILE_NAME) == null ? null : assetData.get(ORIGINAL_FILE_NAME).toString()\n        );\n        return file;\n    }\n    private String getTargetFolder(Map<String, CompositeVariant> assetData) {\n        String target = assetData.get(TARGET_FOLDER).toString();\n        String target = assetData.get(TARGET_FOLDER) == null ? null : assetData.get(TARGET_FOLDER).toString();\n        if (target == null || target.isEmpty()) {\n            return UNKNOWN_TARGET_FOLDER;\n        } else if (!target.startsWith(CONTENT_BASE)) {",
        "Label": "NPE_Fix"
    },
    {
        "ID": 374231981.0,
        "Patch": "src/main/java/com/adobe/acs/commons/mcp/impl/processes/asset/UrlAssetImport.java\n@@ -299,15 +299,15 @@ public class UrlAssetImport extends AssetIngestor {\n        FileOrRendition file = new FileOrRendition(this::getHttpClient, name, source, folder, assetData);\n        file.setAsRenditionOfImage(\n                assetData.get(RENDITION_NAME).toString(),\n                assetData.get(ORIGINAL_FILE_NAME).toString()\n                assetData.get(RENDITION_NAME) == null ? null : assetData.get(RENDITION_NAME).toString(),\n                assetData.get(ORIGINAL_FILE_NAME) == null ? null : assetData.get(ORIGINAL_FILE_NAME).toString()\n        );\n        return file;\n    }\n    private String getTargetFolder(Map<String, CompositeVariant> assetData) {\n        String target = assetData.get(TARGET_FOLDER).toString();\n        String target = assetData.get(TARGET_FOLDER) == null ? null : assetData.get(TARGET_FOLDER).toString();\n        if (target == null || target.isEmpty()) {\n            return UNKNOWN_TARGET_FOLDER;\n        } else if (!target.startsWith(CONTENT_BASE)) {\n+1, -1•bundle/src/main/java/com/adobe/acs/commons/mcp/util/Spreadsheet.java\n@@ -68,7 +68,7 @@ public class Spreadsheet {\n    public Spreadsheet(boolean convertHeaderNames, String... headerArray) {\n        this.enableHeaderNameConversion = convertHeaderNames;\n        headerTypes = Arrays.stream(headerArray).collect(Collectors.toMap(this::convertHeaderName, this::detectTypeFromName));\n        headerRow = new ArrayList(headerTypes.keySet());\n        headerRow = Arrays.asList(headerArray);\n        requiredColumns = Collections.EMPTY_LIST;\n        dataRows = new ArrayList<>();\n        delimiters = new HashMap<>();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 439308121.0,
        "Patch": "20,7 +20,6 @@\npackage com.adobe.acs.commons.functions;\nimport aQute.bnd.annotation.ConsumerType;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n/**\n@@ -40,8 +39,8 @@ import java.util.function.BiConsumer;\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedBiConsumer<T, U> {\n    public static <T,U> CheckedBiConsumer<T,U> from(BiConsumer<T,U> handler) {\n        return (t, u) -> handler.accept(t, u);\n    static <T,U> CheckedBiConsumer<T,U> from(BiConsumer<T,U> handler) {\n        return handler == null ? null : (t, u) -> handler.accept(t, u);\n    }\n    /**\n+3•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedBiFunction.java\n@@ -36,6 +36,9 @@ import aQute.bnd.annotation.ConsumerType;\n@FunctionalInterface\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedBiFunction<T, U, R> {\n    static <T,U,R> CheckedBiFunction<T, U, R> from(java.util.function.BiFunction<T,U,R> function) {\n        return function == null ? null : (t, u) -> function.apply(t, u);\n    }\n    /**\n     * Applies this function to the given arguments.\n+3•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedConsumer.java\n33,6 +33,9 @@ import aQute.bnd.annotation.ConsumerType;\n@FunctionalInterface\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedConsumer<T> {\n    static <T> CheckedConsumer<T> from(java.util.function.Consumer<T> consumer) {\n        return consumer == null ? null : t -> consumer.accept(t);\n    }\n    void accept(T t) throws Exception;\n+1, -1•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedFunction.java\n@@ -35,7 +35,7 @@ import java.util.function.Function;\npublic interface CheckedFunction<T, R> {\n    public static <T,R> CheckedFunction<T,R> from(Function<T,R> function) {\n        return t -> function.apply(t);\n        return function == null ? null : t -> function.apply(t);\n    }\n    /**\n+2, -2•bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/BrokenLinksReport.java\n@@ -132,8 +132,8 @@ public class BrokenLinksReport extends ProcessDefinition implements Serializable\n    public void buildReport(ActionManager manager) {\n        TreeFilteringResourceVisitor visitor = new TreeFilteringResourceVisitor();\n        visitor.setBreadthFirstMode();\n        visitor.setTraversalFilter(null);\n        visitor.setResourceVisitor((resource, depth) -> {\n        visitor.setTraversalFilterChecked(null);\n        visitor.setResourceVisitorChecked((resource, depth) -> {\n            manager.deferredWithResolver(rr -> {\n                Map<String, List<String>> brokenRefs = collectBrokenReferences(resource, regex, excludeList, deepCheckList);\n                for(Map.Entry<String, List<String>> ref : brokenRefs.entrySet()){",
        "Label": "NPE_Fix"
    },
    {
        "ID": 439308122.0,
        "Patch": "bundle/src/main/java/com/adobe/acs/commons/functions/CheckedBiConsumer.java\n@@ -20,7 +20,6 @@\npackage com.adobe.acs.commons.functions;\nimport aQute.bnd.annotation.ConsumerType;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n/**\n@@ -40,8 +39,8 @@ import java.util.function.BiConsumer;\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedBiConsumer<T, U> {\n    public static <T,U> CheckedBiConsumer<T,U> from(BiConsumer<T,U> handler) {\n        return (t, u) -> handler.accept(t, u);\n    static <T,U> CheckedBiConsumer<T,U> from(BiConsumer<T,U> handler) {\n        return handler == null ? null : (t, u) -> handler.accept(t, u);\n    }\n    /**\n+3•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedBiFunction.java\n@@ -36,6 +36,9 @@ import aQute.bnd.annotation.ConsumerType;\n@FunctionalInterface\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedBiFunction<T, U, R> {\n    static <T,U,R> CheckedBiFunction<T, U, R> from(java.util.function.BiFunction<T,U,R> function) {\n        return function == null ? null : (t, u) -> function.apply(t, u);\n    }\n    /**\n     * Applies this function to the given arguments.\n+3•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedConsumer.java\n@@ -33,6 +33,9 @@ import aQute.bnd.annotation.ConsumerType;\n@FunctionalInterface\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedConsumer<T> {\n    static <T> CheckedConsumer<T> from(java.util.function.Consumer<T> consumer) {\n        return consumer == null ? null : t -> consumer.accept(t);\n    }\n    void accept(T t) throws Exception;\n+1, -1•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedFunction.java\n@@ -35,7 +35,7 @@ import java.util.function.Function;\npublic interface CheckedFunction<T, R> {\n    public static <T,R> CheckedFunction<T,R> from(Function<T,R> function) {\n        return t -> function.apply(t);\n        return function == null ? null : t -> function.apply(t);\n    }\n    /**\n+2, -2•bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/BrokenLinksReport.java\n@@ -132,8 +132,8 @@ public class BrokenLinksReport extends ProcessDefinition implements Serializable\n    public void buildReport(ActionManager manager) {\n        TreeFilteringResourceVisitor visitor = new TreeFilteringResourceVisitor();\n        visitor.setBreadthFirstMode();\n        visitor.setTraversalFilter(null);\n        visitor.setResourceVisitor((resource, depth) -> {\n        visitor.setTraversalFilterChecked(null);\n        visitor.setResourceVisitorChecked((resource, depth) -> {\n            manager.deferredWithResolver(rr -> {\n                Map<String, List<String>> brokenRefs = collectBrokenReferences(resource, regex, excludeList, deepCheckList);\n                for(Map.Entry<String, List<String>> ref : brokenRefs.entrySet()){",
        "Label": "NPE_Fix"
    },
    {
        "ID": 439308123.0,
        "Patch": "src/main/java/com/adobe/acs/commons/functions/CheckedBiConsumer.java\n@@ -20,7 +20,6 @@\npackage com.adobe.acs.commons.functions;\nimport aQute.bnd.annotation.ConsumerType;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n/**\n@@ -40,8 +39,8 @@ import java.util.function.BiConsumer;\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedBiConsumer<T, U> {\n    public static <T,U> CheckedBiConsumer<T,U> from(BiConsumer<T,U> handler) {\n        return (t, u) -> handler.accept(t, u);\n    static <T,U> CheckedBiConsumer<T,U> from(BiConsumer<T,U> handler) {\n        return handler == null ? null : (t, u) -> handler.accept(t, u);\n    }\n    /**\n+3•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedBiFunction.java\n@@ -36,6 +36,9 @@ import aQute.bnd.annotation.ConsumerType;\n@FunctionalInterface\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedBiFunction<T, U, R> {\n    static <T,U,R> CheckedBiFunction<T, U, R> from(java.util.function.BiFunction<T,U,R> function) {\n        return function == null ? null : (t, u) -> function.apply(t, u);\n    }\n    /**\n     * Applies this function to the given arguments.\n+3•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedConsumer.java\n@@ -33,6 +33,9 @@ import aQute.bnd.annotation.ConsumerType;\n@FunctionalInterface\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedConsumer<T> {\n    static <T> CheckedConsumer<T> from(java.util.function.Consumer<T> consumer) {\n        return consumer == null ? null : t -> consumer.accept(t);\n    }\n    void accept(T t) throws Exception;\n+1, -1•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedFunction.java\n@@ -35,7 +35,7 @@ import java.util.function.Function;\npublic interface CheckedFunction<T, R> {\n    public static <T,R> CheckedFunction<T,R> from(Function<T,R> function) {\n        return t -> function.apply(t);\n        return function == null ? null : t -> function.apply(t);\n    }\n    /**\n+2, -2•bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/BrokenLinksReport.java\n@@ -132,8 +132,8 @@ public class BrokenLinksReport extends ProcessDefinition implements Serializable\n    public void buildReport(ActionManager manager) {\n        TreeFilteringResourceVisitor visitor = new TreeFilteringResourceVisitor();\n        visitor.setBreadthFirstMode();\n        visitor.setTraversalFilter(null);\n        visitor.setResourceVisitor((resource, depth) -> {\n        visitor.setTraversalFilterChecked(null);\n        visitor.setResourceVisitorChecked((resource, depth) -> {\n            manager.deferredWithResolver(rr -> {\n                Map<String, List<String>> brokenRefs = collectBrokenReferences(resource, regex, excludeList, deepCheckList);\n                for(Map.Entry<String, List<String>> ref : brokenRefs.entrySet()){",
        "Label": "NPE_Fix"
    },
    {
        "ID": 439308124.0,
        "Patch": "main/java/com/adobe/acs/commons/functions/CheckedBiConsumer.java\n@@ -20,7 +20,6 @@\npackage com.adobe.acs.commons.functions;\nimport aQute.bnd.annotation.ConsumerType;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n/**\n@@ -40,8 +39,8 @@ import java.util.function.BiConsumer;\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedBiConsumer<T, U> {\n    public static <T,U> CheckedBiConsumer<T,U> from(BiConsumer<T,U> handler) {\n        return (t, u) -> handler.accept(t, u);\n    static <T,U> CheckedBiConsumer<T,U> from(BiConsumer<T,U> handler) {\n        return handler == null ? null : (t, u) -> handler.accept(t, u);\n    }\n    /**\n+3•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedBiFunction.java\n@@ -36,6 +36,9 @@ import aQute.bnd.annotation.ConsumerType;\n@FunctionalInterface\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedBiFunction<T, U, R> {\n    static <T,U,R> CheckedBiFunction<T, U, R> from(java.util.function.BiFunction<T,U,R> function) {\n        return function == null ? null : (t, u) -> function.apply(t, u);\n    }\n    /**\n     * Applies this function to the given arguments.\n+3•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedConsumer.java\n@@ -33,6 +33,9 @@ import aQute.bnd.annotation.ConsumerType;\n@FunctionalInterface\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedConsumer<T> {\n    static <T> CheckedConsumer<T> from(java.util.function.Consumer<T> consumer) {\n        return consumer == null ? null : t -> consumer.accept(t);\n    }\n    void accept(T t) throws Exception;\n+1, -1•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedFunction.java\n@@ -35,7 +35,7 @@ import java.util.function.Function;\npublic interface CheckedFunction<T, R> {\n    public static <T,R> CheckedFunction<T,R> from(Function<T,R> function) {\n        return t -> function.apply(t);\n        return function == null ? null : t -> function.apply(t);\n    }\n    /**\n+2, -2•bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/BrokenLinksReport.java\n@@ -132,8 +132,8 @@ public class BrokenLinksReport extends ProcessDefinition implements Serializable\n    public void buildReport(ActionManager manager) {\n        TreeFilteringResourceVisitor visitor = new TreeFilteringResourceVisitor();\n        visitor.setBreadthFirstMode();\n        visitor.setTraversalFilter(null);\n        visitor.setResourceVisitor((resource, depth) -> {\n        visitor.setTraversalFilterChecked(null);\n        visitor.setResourceVisitorChecked((resource, depth) -> {\n            manager.deferredWithResolver(rr -> {\n                Map<String, List<String>> brokenRefs = collectBrokenReferences(resource, regex, excludeList, deepCheckList);\n                for(Map.Entry<String, List<String>> ref : brokenRefs.entrySet()){",
        "Label": "NPE_Fix"
    },
    {
        "ID": 439308182.0,
        "Patch": "20,7 +20,6 @@\npackage com.adobe.acs.commons.functions;\nimport aQute.bnd.annotation.ConsumerType;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n/**\n@@ -40,8 +39,8 @@ import java.util.function.BiConsumer;\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedBiConsumer<T, U> {\n    public static <T,U> CheckedBiConsumer<T,U> from(BiConsumer<T,U> handler) {\n        return (t, u) -> handler.accept(t, u);\n    static <T,U> CheckedBiConsumer<T,U> from(BiConsumer<T,U> handler) {\n        return handler == null ? null : (t, u) -> handler.accept(t, u);\n    }\n    /**\n+3•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedBiFunction.java\n@@ -36,6 +36,9 @@ import aQute.bnd.annotation.ConsumerType;\n@FunctionalInterface\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedBiFunction<T, U, R> {\n    static <T,U,R> CheckedBiFunction<T, U, R> from(java.util.function.BiFunction<T,U,R> function) {\n        return function == null ? null : (t, u) -> function.apply(t, u);\n    }\n    /**\n     * Applies this function to the given arguments.\n+3•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedConsumer.java\n@@ -33,6 +33,9 @@ import aQute.bnd.annotation.ConsumerType;\n@FunctionalInterface\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedConsumer<T> {\n    static <T> CheckedConsumer<T> from(java.util.function.Consumer<T> consumer) {\n        return consumer == null ? null : t -> consumer.accept(t);\n    }\n    void accept(T t) throws Exception;\n+1, -1•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedFunction.java\n@@ -35,7 +35,7 @@ import java.util.function.Function;\npublic interface CheckedFunction<T, R> {\n    public static <T,R> CheckedFunction<T,R> from(Function<T,R> function) {\n        return t -> function.apply(t);\n        return function == null ? null : t -> function.apply(t);\n    }\n    /**\n+2, -2•bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/BrokenLinksReport.java\n@@ -132,8 +132,8 @@ public class BrokenLinksReport extends ProcessDefinition implements Serializable\n    public void buildReport(ActionManager manager) {\n        TreeFilteringResourceVisitor visitor = new TreeFilteringResourceVisitor();\n        visitor.setBreadthFirstMode();\n        visitor.setTraversalFilter(null);\n        visitor.setResourceVisitor((resource, depth) -> {\n        visitor.setTraversalFilterChecked(null);\n        visitor.setResourceVisitorChecked((resource, depth) -> {\n            manager.deferredWithResolver(rr -> {\n                Map<String, List<String>> brokenRefs = collectBrokenReferences(resource, regex, excludeList, deepCheckList);\n                for(Map.Entry<String, List<String>> ref : brokenRefs.entrySet()){",
        "Label": "NPE_Fix"
    },
    {
        "ID": 439308183.0,
        "Patch": "bundle/src/main/java/com/adobe/acs/commons/functions/CheckedBiConsumer.java\n@@ -20,7 +20,6 @@\npackage com.adobe.acs.commons.functions;\nimport aQute.bnd.annotation.ConsumerType;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n/**\n@@ -40,8 +39,8 @@ import java.util.function.BiConsumer;\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedBiConsumer<T, U> {\n    public static <T,U> CheckedBiConsumer<T,U> from(BiConsumer<T,U> handler) {\n        return (t, u) -> handler.accept(t, u);\n    static <T,U> CheckedBiConsumer<T,U> from(BiConsumer<T,U> handler) {\n        return handler == null ? null : (t, u) -> handler.accept(t, u);\n    }\n    /**\n+3•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedBiFunction.java\n@@ -36,6 +36,9 @@ import aQute.bnd.annotation.ConsumerType;\n@FunctionalInterface\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedBiFunction<T, U, R> {\n    static <T,U,R> CheckedBiFunction<T, U, R> from(java.util.function.BiFunction<T,U,R> function) {\n        return function == null ? null : (t, u) -> function.apply(t, u);\n    }\n    /**\n     * Applies this function to the given arguments.\n+3•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedConsumer.java\n@@ -33,6 +33,9 @@ import aQute.bnd.annotation.ConsumerType;\n@FunctionalInterface\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedConsumer<T> {\n    static <T> CheckedConsumer<T> from(java.util.function.Consumer<T> consumer) {\n        return consumer == null ? null : t -> consumer.accept(t);\n    }\n    void accept(T t) throws Exception;\n+1, -1•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedFunction.java\n@@ -35,7 +35,7 @@ import java.util.function.Function;\npublic interface CheckedFunction<T, R> {\n    public static <T,R> CheckedFunction<T,R> from(Function<T,R> function) {\n        return t -> function.apply(t);\n        return function == null ? null : t -> function.apply(t);\n    }\n    /**\n+2, -2•bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/BrokenLinksReport.java\n@@ -132,8 +132,8 @@ public class BrokenLinksReport extends ProcessDefinition implements Serializable\n    public void buildReport(ActionManager manager) {\n        TreeFilteringResourceVisitor visitor = new TreeFilteringResourceVisitor();\n        visitor.setBreadthFirstMode();\n        visitor.setTraversalFilter(null);\n        visitor.setResourceVisitor((resource, depth) -> {\n        visitor.setTraversalFilterChecked(null);\n        visitor.setResourceVisitorChecked((resource, depth) -> {\n            manager.deferredWithResolver(rr -> {\n                Map<String, List<String>> brokenRefs = collectBrokenReferences(resource, regex, excludeList, deepCheckList);\n                for(Map.Entry<String, List<String>> ref : brokenRefs.entrySet()){",
        "Label": "NPE_Fix"
    },
    {
        "ID": 439308184.0,
        "Patch": "src/main/java/com/adobe/acs/commons/functions/CheckedBiConsumer.java\n@@ -20,7 +20,6 @@\npackage com.adobe.acs.commons.functions;\nimport aQute.bnd.annotation.ConsumerType;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n/**\n@@ -40,8 +39,8 @@ import java.util.function.BiConsumer;\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedBiConsumer<T, U> {\n    public static <T,U> CheckedBiConsumer<T,U> from(BiConsumer<T,U> handler) {\n        return (t, u) -> handler.accept(t, u);\n    static <T,U> CheckedBiConsumer<T,U> from(BiConsumer<T,U> handler) {\n        return handler == null ? null : (t, u) -> handler.accept(t, u);\n    }\n    /**\n+3•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedBiFunction.java\n@@ -36,6 +36,9 @@ import aQute.bnd.annotation.ConsumerType;\n@FunctionalInterface\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedBiFunction<T, U, R> {\n    static <T,U,R> CheckedBiFunction<T, U, R> from(java.util.function.BiFunction<T,U,R> function) {\n        return function == null ? null : (t, u) -> function.apply(t, u);\n    }\n    /**\n     * Applies this function to the given arguments.\n+3•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedConsumer.java\n@@ -33,6 +33,9 @@ import aQute.bnd.annotation.ConsumerType;\n@FunctionalInterface\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedConsumer<T> {\n    static <T> CheckedConsumer<T> from(java.util.function.Consumer<T> consumer) {\n        return consumer == null ? null : t -> consumer.accept(t);\n    }\n    void accept(T t) throws Exception;\n+1, -1•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedFunction.java\n@@ -35,7 +35,7 @@ import java.util.function.Function;\npublic interface CheckedFunction<T, R> {\n    public static <T,R> CheckedFunction<T,R> from(Function<T,R> function) {\n        return t -> function.apply(t);\n        return function == null ? null : t -> function.apply(t);\n    }\n    /**\n+2, -2•bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/BrokenLinksReport.java\n@@ -132,8 +132,8 @@ public class BrokenLinksReport extends ProcessDefinition implements Serializable\n    public void buildReport(ActionManager manager) {\n        TreeFilteringResourceVisitor visitor = new TreeFilteringResourceVisitor();\n        visitor.setBreadthFirstMode();\n        visitor.setTraversalFilter(null);\n        visitor.setResourceVisitor((resource, depth) -> {\n        visitor.setTraversalFilterChecked(null);\n        visitor.setResourceVisitorChecked((resource, depth) -> {\n            manager.deferredWithResolver(rr -> {\n                Map<String, List<String>> brokenRefs = collectBrokenReferences(resource, regex, excludeList, deepCheckList);\n                for(Map.Entry<String, List<String>> ref : brokenRefs.entrySet()){",
        "Label": "NPE_Fix"
    },
    {
        "ID": 439308185.0,
        "Patch": "package com.adobe.acs.commons.functions;\nimport aQute.bnd.annotation.ConsumerType;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n/**\n@@ -40,8 +39,8 @@ import java.util.function.BiConsumer;\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedBiConsumer<T, U> {\n    public static <T,U> CheckedBiConsumer<T,U> from(BiConsumer<T,U> handler) {\n        return (t, u) -> handler.accept(t, u);\n    static <T,U> CheckedBiConsumer<T,U> from(BiConsumer<T,U> handler) {\n        return handler == null ? null : (t, u) -> handler.accept(t, u);\n    }\n    /**\n+3•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedBiFunction.java\n@@ -36,6 +36,9 @@ import aQute.bnd.annotation.ConsumerType;\n@FunctionalInterface\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedBiFunction<T, U, R> {\n    static <T,U,R> CheckedBiFunction<T, U, R> from(java.util.function.BiFunction<T,U,R> function) {\n        return function == null ? null : (t, u) -> function.apply(t, u);\n    }\n    /**\n     * Applies this function to the given arguments.\n+3•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedConsumer.java\n@@ -33,6 +33,9 @@ import aQute.bnd.annotation.ConsumerType;\n@FunctionalInterface\n@SuppressWarnings(\"squid:S00112\")\npublic interface CheckedConsumer<T> {\n    static <T> CheckedConsumer<T> from(java.util.function.Consumer<T> consumer) {\n        return consumer == null ? null : t -> consumer.accept(t);\n    }\n    void accept(T t) throws Exception;\n+1, -1•bundle/src/main/java/com/adobe/acs/commons/functions/CheckedFunction.java\n@@ -35,7 +35,7 @@ import java.util.function.Function;\npublic interface CheckedFunction<T, R> {\n    public static <T,R> CheckedFunction<T,R> from(Function<T,R> function) {\n        return t -> function.apply(t);\n        return function == null ? null : t -> function.apply(t);\n    }\n    /**\n+2, -2•bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/BrokenLinksReport.java\n@@ -132,8 +132,8 @@ public class BrokenLinksReport extends ProcessDefinition implements Serializable\n    public void buildReport(ActionManager manager) {\n        TreeFilteringResourceVisitor visitor = new TreeFilteringResourceVisitor();\n        visitor.setBreadthFirstMode();\n        visitor.setTraversalFilter(null);\n        visitor.setResourceVisitor((resource, depth) -> {\n        visitor.setTraversalFilterChecked(null);\n        visitor.setResourceVisitorChecked((resource, depth) -> {\n            manager.deferredWithResolver(rr -> {\n                Map<String, List<String>> brokenRefs = collectBrokenReferences(resource, regex, excludeList, deepCheckList);\n                for(Map.Entry<String, List<String>> ref : brokenRefs.entrySet()){",
        "Label": "NPE_Fix"
    },
    {
        "ID": 456539770.0,
        "Patch": "public class ComponentErrorHandlerImpl implements ComponentErrorHandler, Filter\n    public final void doFilter(ServletRequest servletRequest, ServletResponse servletResponse,\n                               FilterChain chain) throws IOException, ServletException {\n        // We are in a Sling Filter, so these request/response objects are guarenteed to be of type Sling...\n        // We are in a Sling Filter, so these request/response objects are guaranteed to be of type Sling...\n        final SlingHttpServletRequest request = (SlingHttpServletRequest) servletRequest;\n        final SlingHttpServletResponse response = (SlingHttpServletResponse) servletResponse;\n+1, -1•bundle/src/test/java/com/adobe/acs/commons/util/RunnableOnMasterTest.java\n@@ -37,7 +37,7 @@ public class RunnableOnMasterTest {\n        InstanceDescription instanceDescription = mock(InstanceDescription.class);\n        when(te.getNewView()).thenReturn(view);\n        when(view.getLocalInstance()).thenReturn(instanceDescription);\n        when(instanceDescription.isLeader()).thenReturn(true);\n        when(instanceDescription.isLeader()).thenReturn(isLeader);\n        return te;\n    }\n+3, -2•bundle/src/test/java/com/adobe/acs/commons/wcm/impl/ComponentErrorHandlerImplTest.java\n@@ -23,6 +23,7 @@ package com.adobe.acs.commons.wcm.impl;\nimport com.adobe.acs.commons.util.ModeUtil;\nimport com.adobe.acs.commons.wcm.ComponentErrorHandler;\nimport com.adobe.acs.commons.wcm.ComponentHelper;\nimport com.day.cq.wcm.api.WCMMode;\nimport com.day.cq.wcm.api.components.Component;\nimport com.day.cq.wcm.api.components.ComponentContext;\nimport org.apache.sling.api.SlingHttpServletRequest;\n@@ -179,9 +180,9 @@ public class ComponentErrorHandlerImplTest {\n    @Test\n    public void testEditError() throws Exception {\n        when(componentContext.isRoot()).thenReturn(false);\n        when(ModeUtil.isEdit(request)).thenReturn(true);\n        when(request.getAttribute(WCMMode.class.getName())).thenReturn(WCMMode.EDIT);\n        doThrow(new ServletException()).when(chain).doFilter(request, response);\n        doThrow(new ServletException(\"Should not delegate to chained filters\")).when(chain).doFilter(request, response);\n        handler.doFilter(request, response, chain);",
        "Label": "NPE_Fix"
    },
    {
        "ID": 29662120998.0,
        "Patch": "32,7 +32,7 @@ class CompressionContext\n    {\n        this.parameters = parameters;\n        int windowSize = clamp(parameters.getWindowSize(), 1, inputSize);\n        int windowSize = clamp(inputSize, 1, parameters.getWindowSize());\n        int blockSize = Math.min(MAX_BLOCK_SIZE, windowSize);\n        int divider = (parameters.getSearchLength() == 3) ? 3 : 4;",
        "Label": "NPE_Fix"
    },
    {
        "ID": 13283643223.0,
        "Patch": "public abstract class JSONWriter\n    public abstract void writeZonedDateTime(ZonedDateTime dateTime);\n    public abstract void writeOffsetDateTime(OffsetDateTime dateTime);\n    public void writeInstant(Instant instant) {\n        if (instant == null) {\n            writeNull();\n+36•core/src/main/java/com/alibaba/fastjson2/JSONWriterJSONB.java\n@@ -20,6 +20,7 @@ import java.util.*;\nimport static com.alibaba.fastjson2.JSONB.Constants.*;\nimport static com.alibaba.fastjson2.JSONFactory.*;\nimport static com.alibaba.fastjson2.JSONWriter.Feature.WriteNameAsSymbol;\nimport static com.alibaba.fastjson2.util.DateUtils.OFFSET_8_ZONE_ID_NAME;\nimport static com.alibaba.fastjson2.util.DateUtils.SHANGHAI_ZONE_ID_NAME;\nimport static com.alibaba.fastjson2.util.JDKUtils.*;\nimport static com.alibaba.fastjson2.util.TypeUtils.*;\n@@ -28,6 +29,7 @@ final class JSONWriterJSONB\n        extends JSONWriter {\n    // optimize for write ZonedDateTime\n    static final byte[] SHANGHAI_ZONE_ID_NAME_BYTES = JSONB.toBytes(SHANGHAI_ZONE_ID_NAME);\n    static final byte[] OFFSET_8_ZONE_ID_NAME_BYTES = JSONB.toBytes(OFFSET_8_ZONE_ID_NAME);\n    private final CacheItem cacheItem;\n    private byte[] bytes;\n@@ -1515,6 +1517,40 @@ final class JSONWriterJSONB\n        }\n    }\n    @Override\n    public void writeOffsetDateTime(OffsetDateTime dateTime) {\n        if (dateTime == null) {\n            writeNull();\n            return;\n        }\n        ensureCapacity(off + 8);\n        bytes[off++] = BC_TIMESTAMP_WITH_TIMEZONE;\n        int year = dateTime.getYear();\n        bytes[off++] = (byte) (year >>> 8);\n        bytes[off++] = (byte) year;\n        bytes[off++] = (byte) dateTime.getMonthValue();\n        bytes[off++] = (byte) dateTime.getDayOfMonth();\n        bytes[off++] = (byte) dateTime.getHour();\n        bytes[off++] = (byte) dateTime.getMinute();\n        bytes[off++] = (byte) dateTime.getSecond();\n        int nano = dateTime.getNano();\n        writeInt32(nano);\n        ZoneId zoneId = dateTime.getOffset();\n        String zoneIdStr = zoneId.getId();\n        switch (zoneIdStr) {\n            case OFFSET_8_ZONE_ID_NAME:\n                writeRaw(OFFSET_8_ZONE_ID_NAME_BYTES);\n                break;\n            default:\n                writeString(zoneIdStr);\n                break;\n        }\n    }\n    @Override\n    public void writeInstant(Instant instant) {\n        if (instant == null) {\n+6, -4•core/src/main/java/com/alibaba/fastjson2/JSONWriterPretty.java\n@@ -7,10 +7,7 @@ import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport java.text.DecimalFormat;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\nimport java.time.*;\nimport java.util.UUID;\nfinal class JSONWriterPretty\n@@ -148,6 +145,11 @@ final class JSONWriterPretty\n        jsonWriter.writeZonedDateTime(dateTime);\n    }\n    @Override\n    public void writeOffsetDateTime(OffsetDateTime dateTime) {\n        jsonWriter.writeOffsetDateTime(dateTime);\n    }\n    @Override\n    public void writeReference(String path) {\n        jsonWriter.writeReference(path);\n+97, -5•core/src/main/java/com/alibaba/fastjson2/JSONWriterUTF16.java\n@@ -10,10 +10,7 @@ import java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.text.DecimalFormat;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\nimport java.time.*;\nimport java.util.*;\nimport static com.alibaba.fastjson2.JSONFactory.*;\n@@ -1991,7 +1988,102 @@ class JSONWriterUTF16\n        char firstZoneChar = '\\0';\n        int zoneSize;\n        if (\"UTC\".equals(zoneId)) {\n        if (\"UTC\".equals(zoneId) || \"Z\".equals(zoneId)) {\n            zoneId = \"Z\";\n            zoneSize = 1;\n        } else if (zoneId.length() != 0 && ((firstZoneChar = zoneId.charAt(0)) == '+' || firstZoneChar == '-')) {\n            zoneSize = zoneId.length();\n        } else {\n            zoneSize = 2 + zoneId.length();\n        }\n        len += zoneSize;\n        int yearSize = IOUtils.stringSize(year);\n        len += yearSize;\n        int small;\n        if (nano % 1000_000_000 == 0) {\n            small = 0;\n        } else if (nano % 1000_000_00 == 0) {\n            len += 2;\n            small = nano / 1000_000_00;\n        } else if (nano % 1000_000_0 == 0) {\n            len += 3;\n            small = nano / 1000_000_0;\n        } else if (nano % 1000_000 == 0) {\n            len += 4;\n            small = nano / 1000_000;\n        } else if (nano % 1000_00 == 0) {\n            len += 5;\n            small = nano / 1000_00;\n        } else if (nano % 1000_0 == 0) {\n            len += 6;\n            small = nano / 1000_0;\n        } else if (nano % 1000 == 0) {\n            len += 7;\n            small = nano / 1000;\n        } else if (nano % 100 == 0) {\n            len += 8;\n            small = nano / 100;\n        } else if (nano % 10 == 0) {\n            len += 9;\n            small = nano / 10;\n        } else {\n            len += 10;\n            small = nano;\n        }\n        ensureCapacity(off + len);\n        chars[off] = quote;\n        Arrays.fill(chars, off + 1, off + len - 1, '0');\n        IOUtils.getChars(year, off + yearSize + 1, chars);\n        chars[off + yearSize + 1] = '-';\n        IOUtils.getChars(month, off + yearSize + 4, chars);\n        chars[off + yearSize + 4] = '-';\n        IOUtils.getChars(dayOfMonth, off + yearSize + 7, chars);\n        chars[off + yearSize + 7] = 'T';\n        IOUtils.getChars(hour, off + yearSize + 10, chars);\n        chars[off + yearSize + 10] = ':';\n        IOUtils.getChars(minute, off + yearSize + 13, chars);\n        chars[off + yearSize + 13] = ':';\n        IOUtils.getChars(second, off + yearSize + 16, chars);\n        if (small != 0) {\n            chars[off + yearSize + 16] = '.';\n            IOUtils.getChars(small, off + len - 1 - zoneSize, chars);\n        }\n        if (zoneSize == 1) {\n            chars[off + len - 2] = 'Z';\n        } else if (firstZoneChar == '+' || firstZoneChar == '-') {\n            zoneId.getChars(0, zoneId.length(), chars, off + len - zoneSize - 1);\n        } else {\n            chars[off + len - zoneSize - 1] = '[';\n            zoneId.getChars(0, zoneId.length(), chars, off + len - zoneSize);\n            chars[off + len - 2] = ']';\n        }\n        chars[off + len - 1] = quote;\n        off += len;\n    }\n    @Override\n    public final void writeOffsetDateTime(OffsetDateTime dateTime) {\n        if (dateTime == null) {\n            writeNull();\n            return;\n        }\n        int year = dateTime.getYear();\n        int month = dateTime.getMonthValue();\n        int dayOfMonth = dateTime.getDayOfMonth();\n        int hour = dateTime.getHour();\n        int minute = dateTime.getMinute();\n        int second = dateTime.getSecond();\n        int nano = dateTime.getNano();\n        String zoneId = dateTime.getOffset().getId();\n        int len = 17;\n        char firstZoneChar = '\\0';\n        int zoneSize;\n        if (\"UTC\".equals(zoneId) || \"Z\".equals(zoneId)) {\n            zoneId = \"Z\";\n            zoneSize = 1;\n        } else if (zoneId.length() != 0 && ((firstZoneChar = zoneId.charAt(0)) == '+' || firstZoneChar == '-')) {\n+97, -5•core/src/main/java/com/alibaba/fastjson2/JSONWriterUTF8.java\n@@ -10,10 +10,7 @@ import java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.text.DecimalFormat;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\nimport java.time.*;\nimport java.util.*;\nimport static com.alibaba.fastjson2.JSONFactory.*;\n@@ -2095,7 +2092,102 @@ class JSONWriterUTF8\n        char firstZoneChar = '\\0';\n        int zoneSize;\n        if (\"UTC\".equals(zoneId)) {\n        if (\"UTC\".equals(zoneId) || \"Z\".equals(zoneId)) {\n            zoneId = \"Z\";\n            zoneSize = 1;\n        } else if (zoneId.length() != 0 && ((firstZoneChar = zoneId.charAt(0)) == '+' || firstZoneChar == '-')) {\n            zoneSize = zoneId.length();\n        } else {\n            zoneSize = 2 + zoneId.length();\n        }\n        len += zoneSize;\n        int yearSize = IOUtils.stringSize(year);\n        len += yearSize;\n        int small;\n        if (nano % 1000_000_000 == 0) {\n            small = 0;\n        } else if (nano % 1000_000_00 == 0) {\n            len += 2;\n            small = nano / 1000_000_00;\n        } else if (nano % 1000_000_0 == 0) {\n            len += 3;\n            small = nano / 1000_000_0;\n        } else if (nano % 1000_000 == 0) {\n            len += 4;\n            small = nano / 1000_000;\n        } else if (nano % 1000_00 == 0) {\n            len += 5;\n            small = nano / 1000_00;\n        } else if (nano % 1000_0 == 0) {\n            len += 6;\n            small = nano / 1000_0;\n        } else if (nano % 1000 == 0) {\n            len += 7;\n            small = nano / 1000;\n        } else if (nano % 100 == 0) {\n            len += 8;\n            small = nano / 100;\n        } else if (nano % 10 == 0) {\n            len += 9;\n            small = nano / 10;\n        } else {\n            len += 10;\n            small = nano;\n        }\n        ensureCapacity(off + len);\n        bytes[off] = (byte) quote;\n        Arrays.fill(bytes, off + 1, off + len - 1, (byte) '0');\n        IOUtils.getChars(year, off + yearSize + 1, bytes);\n        bytes[off + yearSize + 1] = '-';\n        IOUtils.getChars(month, off + yearSize + 4, bytes);\n        bytes[off + yearSize + 4] = '-';\n        IOUtils.getChars(dayOfMonth, off + yearSize + 7, bytes);\n        bytes[off + yearSize + 7] = 'T';\n        IOUtils.getChars(hour, off + yearSize + 10, bytes);\n        bytes[off + yearSize + 10] = ':';\n        IOUtils.getChars(minute, off + yearSize + 13, bytes);\n        bytes[off + yearSize + 13] = ':';\n        IOUtils.getChars(second, off + yearSize + 16, bytes);\n        if (small != 0) {\n            bytes[off + yearSize + 16] = '.';\n            IOUtils.getChars(small, off + len - 1 - zoneSize, bytes);\n        }\n        if (zoneSize == 1) {\n            bytes[off + len - 2] = 'Z';\n        } else if (firstZoneChar == '+' || firstZoneChar == '-') {\n            zoneId.getBytes(0, zoneId.length(), bytes, off + len - zoneSize - 1);\n        } else {\n            bytes[off + len - zoneSize - 1] = '[';\n            zoneId.getBytes(0, zoneId.length(), bytes, off + len - zoneSize);\n            bytes[off + len - 2] = ']';\n        }\n        bytes[off + len - 1] = (byte) quote;\n        off += len;\n    }\n    @Override\n    public final void writeOffsetDateTime(OffsetDateTime dateTime) {\n        if (dateTime == null) {\n            writeNull();\n            return;\n        }\n        int year = dateTime.getYear();\n        int month = dateTime.getMonthValue();\n        int dayOfMonth = dateTime.getDayOfMonth();\n        int hour = dateTime.getHour();\n        int minute = dateTime.getMinute();\n        int second = dateTime.getSecond();\n        int nano = dateTime.getNano();\n        String zoneId = dateTime.getOffset().getId();\n        int len = 17;\n        char firstZoneChar = '\\0';\n        int zoneSize;\n        if (\"UTC\".equals(zoneId) || \"Z\".equals(zoneId)) {\n            zoneId = \"Z\";\n            zoneSize = 1;\n        } else if (zoneId.length() != 0 && ((firstZoneChar = zoneId.charAt(0)) == '+' || firstZoneChar == '-')) {\n+1, -1•core/src/main/java/com/alibaba/fastjson2/reader/ObjectReaderImplOffsetDateTime.java\n@@ -31,7 +31,7 @@ final class ObjectReaderImplOffsetDateTime\n    @Override\n    public Object readJSONBObject(JSONReader jsonReader, Type fieldType, Object fieldName, long features) {\n        return jsonReader.readZonedDateTime();\n        return readObject(jsonReader, fieldType, fieldName, features);\n    }\n    @Override\n+1•core/src/main/java/com/alibaba/fastjson2/util/DateUtils.java\n@@ -20,6 +20,7 @@ import static java.time.ZoneOffset.UTC;\npublic class DateUtils {\n    public static final ZoneId DEFAULT_ZONE_ID = ZoneId.systemDefault();\n    public static final String SHANGHAI_ZONE_ID_NAME = \"Asia/Shanghai\";\n    public static final String OFFSET_8_ZONE_ID_NAME = \"+08:00\";\n    public static final ZoneId SHANGHAI_ZONE_ID\n            = SHANGHAI_ZONE_ID_NAME.equals(DEFAULT_ZONE_ID.getId())\n            ? DEFAULT_ZONE_ID\n+1, -3•core/src/main/java/com/alibaba/fastjson2/writer/ObjectWriterImplOffsetDateTime.java\n@@ -5,7 +5,6 @@ import com.alibaba.fastjson2.codec.DateTimeCodec;\nimport java.lang.reflect.Type;\nimport java.time.OffsetDateTime;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Locale;\n@@ -92,8 +91,7 @@ final class ObjectWriterImplOffsetDateTime\n        }\n        if (formatter == null) {\n            ZonedDateTime zdt = odt.toZonedDateTime();\n            jsonWriter.writeZonedDateTime(zdt);\n            jsonWriter.writeOffsetDateTime(odt);\n            return;\n        }\n+4•core/src/test/java/com/alibaba/fastjson2/date/OffsetDateTimeTest.java\n@@ -1,6 +1,7 @@\npackage com.alibaba.fastjson2.date;\nimport com.alibaba.fastjson2.JSON;\nimport com.alibaba.fastjson2.JSONB;\nimport org.junit.jupiter.api.Test;\nimport java.time.OffsetDateTime;\n@@ -14,5 +15,8 @@ public class OffsetDateTimeTest {\n        String str = JSON.toJSONString(odt);\n        OffsetDateTime odt1 = JSON.parseObject(str, OffsetDateTime.class);\n        assertEquals(odt, odt1);\n        OffsetDateTime odt2 = JSONB.parseObject(JSONB.toBytes(odt), OffsetDateTime.class);\n        assertEquals(odt, odt2);\n    }\n}\n+11, -1•core/src/test/java/com/alibaba/fastjson2/time/DateTest.java\n@@ -72,7 +72,17 @@ public class DateTest {\n        jw.writeAny(\n                OffsetDateTime.of(1970, 1, 1, 0, 0, 0, 0, ZoneOffset.ofHours(0)));\n        assertEquals(\"\\\"1970-01-01T00:00Z\\\"\", jw.toString());\n        assertEquals(\"\\\"1970-01-01T00:00:00Z\\\"\", jw.toString());\n    }\n    @Test\n    public void testOffsetDateTimeUTF8() throws Exception {\n        JSONWriter jw = JSONWriter.ofUTF8();\n        jw.getContext().setZoneId(ZoneId.of(\"UTC+0\"));\n        jw.writeAny(\n                OffsetDateTime.of(1970, 1, 1, 0, 0, 0, 0, ZoneOffset.ofHours(0)));\n        assertEquals(\"\\\"1970-01-01T00:00:00Z\\\"\", jw.toString());\n    }\n    @Test",
        "Label": "NPE_Fix"
    },
    {
        "ID": 13283643245.0,
        "Patch": "core/src/main/java/com/alibaba/fastjson2/JSONWriter.java\n@@ -1241,6 +1241,8 @@ public abstract class JSONWriter\n    public abstract void writeZonedDateTime(ZonedDateTime dateTime);\n    public abstract void writeOffsetDateTime(OffsetDateTime dateTime);\n    public void writeInstant(Instant instant) {\n        if (instant == null) {\n            writeNull();\n+36•core/src/main/java/com/alibaba/fastjson2/JSONWriterJSONB.java\n@@ -20,6 +20,7 @@ import java.util.*;\nimport static com.alibaba.fastjson2.JSONB.Constants.*;\nimport static com.alibaba.fastjson2.JSONFactory.*;\nimport static com.alibaba.fastjson2.JSONWriter.Feature.WriteNameAsSymbol;\nimport static com.alibaba.fastjson2.util.DateUtils.OFFSET_8_ZONE_ID_NAME;\nimport static com.alibaba.fastjson2.util.DateUtils.SHANGHAI_ZONE_ID_NAME;\nimport static com.alibaba.fastjson2.util.JDKUtils.*;\nimport static com.alibaba.fastjson2.util.TypeUtils.*;\n@@ -28,6 +29,7 @@ final class JSONWriterJSONB\n        extends JSONWriter {\n    // optimize for write ZonedDateTime\n    static final byte[] SHANGHAI_ZONE_ID_NAME_BYTES = JSONB.toBytes(SHANGHAI_ZONE_ID_NAME);\n    static final byte[] OFFSET_8_ZONE_ID_NAME_BYTES = JSONB.toBytes(OFFSET_8_ZONE_ID_NAME);\n    private final CacheItem cacheItem;\n    private byte[] bytes;\n@@ -1515,6 +1517,40 @@ final class JSONWriterJSONB\n        }\n    }\n    @Override\n    public void writeOffsetDateTime(OffsetDateTime dateTime) {\n        if (dateTime == null) {\n            writeNull();\n            return;\n        }\n        ensureCapacity(off + 8);\n        bytes[off++] = BC_TIMESTAMP_WITH_TIMEZONE;\n        int year = dateTime.getYear();\n        bytes[off++] = (byte) (year >>> 8);\n        bytes[off++] = (byte) year;\n        bytes[off++] = (byte) dateTime.getMonthValue();\n        bytes[off++] = (byte) dateTime.getDayOfMonth();\n        bytes[off++] = (byte) dateTime.getHour();\n        bytes[off++] = (byte) dateTime.getMinute();\n        bytes[off++] = (byte) dateTime.getSecond();\n        int nano = dateTime.getNano();\n        writeInt32(nano);\n        ZoneId zoneId = dateTime.getOffset();\n        String zoneIdStr = zoneId.getId();\n        switch (zoneIdStr) {\n            case OFFSET_8_ZONE_ID_NAME:\n                writeRaw(OFFSET_8_ZONE_ID_NAME_BYTES);\n                break;\n            default:\n                writeString(zoneIdStr);\n                break;\n        }\n    }\n    @Override\n    public void writeInstant(Instant instant) {\n        if (instant == null) {\n+6, -4•core/src/main/java/com/alibaba/fastjson2/JSONWriterPretty.java\n@@ -7,10 +7,7 @@ import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport java.text.DecimalFormat;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\nimport java.time.*;\nimport java.util.UUID;\nfinal class JSONWriterPretty\n@@ -148,6 +145,11 @@ final class JSONWriterPretty\n        jsonWriter.writeZonedDateTime(dateTime);\n    }\n    @Override\n    public void writeOffsetDateTime(OffsetDateTime dateTime) {\n        jsonWriter.writeOffsetDateTime(dateTime);\n    }\n    @Override\n    public void writeReference(String path) {\n        jsonWriter.writeReference(path);\n+97, -5•core/src/main/java/com/alibaba/fastjson2/JSONWriterUTF16.java\n@@ -10,10 +10,7 @@ import java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.text.DecimalFormat;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\nimport java.time.*;\nimport java.util.*;\nimport static com.alibaba.fastjson2.JSONFactory.*;\n@@ -1991,7 +1988,102 @@ class JSONWriterUTF16\n        char firstZoneChar = '\\0';\n        int zoneSize;\n        if (\"UTC\".equals(zoneId)) {\n        if (\"UTC\".equals(zoneId) || \"Z\".equals(zoneId)) {\n            zoneId = \"Z\";\n            zoneSize = 1;\n        } else if (zoneId.length() != 0 && ((firstZoneChar = zoneId.charAt(0)) == '+' || firstZoneChar == '-')) {\n            zoneSize = zoneId.length();\n        } else {\n            zoneSize = 2 + zoneId.length();\n        }\n        len += zoneSize;\n        int yearSize = IOUtils.stringSize(year);\n        len += yearSize;\n        int small;\n        if (nano % 1000_000_000 == 0) {\n            small = 0;\n        } else if (nano % 1000_000_00 == 0) {\n            len += 2;\n            small = nano / 1000_000_00;\n        } else if (nano % 1000_000_0 == 0) {\n            len += 3;\n            small = nano / 1000_000_0;\n        } else if (nano % 1000_000 == 0) {\n            len += 4;\n            small = nano / 1000_000;\n        } else if (nano % 1000_00 == 0) {\n            len += 5;\n            small = nano / 1000_00;\n        } else if (nano % 1000_0 == 0) {\n            len += 6;\n            small = nano / 1000_0;\n        } else if (nano % 1000 == 0) {\n            len += 7;\n            small = nano / 1000;\n        } else if (nano % 100 == 0) {\n            len += 8;\n            small = nano / 100;\n        } else if (nano % 10 == 0) {\n            len += 9;\n            small = nano / 10;\n        } else {\n            len += 10;\n            small = nano;\n        }\n        ensureCapacity(off + len);\n        chars[off] = quote;\n        Arrays.fill(chars, off + 1, off + len - 1, '0');\n        IOUtils.getChars(year, off + yearSize + 1, chars);\n        chars[off + yearSize + 1] = '-';\n        IOUtils.getChars(month, off + yearSize + 4, chars);\n        chars[off + yearSize + 4] = '-';\n        IOUtils.getChars(dayOfMonth, off + yearSize + 7, chars);\n        chars[off + yearSize + 7] = 'T';\n        IOUtils.getChars(hour, off + yearSize + 10, chars);\n        chars[off + yearSize + 10] = ':';\n        IOUtils.getChars(minute, off + yearSize + 13, chars);\n        chars[off + yearSize + 13] = ':';\n        IOUtils.getChars(second, off + yearSize + 16, chars);\n        if (small != 0) {\n            chars[off + yearSize + 16] = '.';\n            IOUtils.getChars(small, off + len - 1 - zoneSize, chars);\n        }\n        if (zoneSize == 1) {\n            chars[off + len - 2] = 'Z';\n        } else if (firstZoneChar == '+' || firstZoneChar == '-') {\n            zoneId.getChars(0, zoneId.length(), chars, off + len - zoneSize - 1);\n        } else {\n            chars[off + len - zoneSize - 1] = '[';\n            zoneId.getChars(0, zoneId.length(), chars, off + len - zoneSize);\n            chars[off + len - 2] = ']';\n        }\n        chars[off + len - 1] = quote;\n        off += len;\n    }\n    @Override\n    public final void writeOffsetDateTime(OffsetDateTime dateTime) {\n        if (dateTime == null) {\n            writeNull();\n            return;\n        }\n        int year = dateTime.getYear();\n        int month = dateTime.getMonthValue();\n        int dayOfMonth = dateTime.getDayOfMonth();\n        int hour = dateTime.getHour();\n        int minute = dateTime.getMinute();\n        int second = dateTime.getSecond();\n        int nano = dateTime.getNano();\n        String zoneId = dateTime.getOffset().getId();\n        int len = 17;\n        char firstZoneChar = '\\0';\n        int zoneSize;\n        if (\"UTC\".equals(zoneId) || \"Z\".equals(zoneId)) {\n            zoneId = \"Z\";\n            zoneSize = 1;\n        } else if (zoneId.length() != 0 && ((firstZoneChar = zoneId.charAt(0)) == '+' || firstZoneChar == '-')) {\n+97, -5•core/src/main/java/com/alibaba/fastjson2/JSONWriterUTF8.java\n@@ -10,10 +10,7 @@ import java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.text.DecimalFormat;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\nimport java.time.*;\nimport java.util.*;\nimport static com.alibaba.fastjson2.JSONFactory.*;\n@@ -2095,7 +2092,102 @@ class JSONWriterUTF8\n        char firstZoneChar = '\\0';\n        int zoneSize;\n        if (\"UTC\".equals(zoneId)) {\n        if (\"UTC\".equals(zoneId) || \"Z\".equals(zoneId)) {\n            zoneId = \"Z\";\n            zoneSize = 1;\n        } else if (zoneId.length() != 0 && ((firstZoneChar = zoneId.charAt(0)) == '+' || firstZoneChar == '-')) {\n            zoneSize = zoneId.length();\n        } else {\n            zoneSize = 2 + zoneId.length();\n        }\n        len += zoneSize;\n        int yearSize = IOUtils.stringSize(year);\n        len += yearSize;\n        int small;\n        if (nano % 1000_000_000 == 0) {\n            small = 0;\n        } else if (nano % 1000_000_00 == 0) {\n            len += 2;\n            small = nano / 1000_000_00;\n        } else if (nano % 1000_000_0 == 0) {\n            len += 3;\n            small = nano / 1000_000_0;\n        } else if (nano % 1000_000 == 0) {\n            len += 4;\n            small = nano / 1000_000;\n        } else if (nano % 1000_00 == 0) {\n            len += 5;\n            small = nano / 1000_00;\n        } else if (nano % 1000_0 == 0) {\n            len += 6;\n            small = nano / 1000_0;\n        } else if (nano % 1000 == 0) {\n            len += 7;\n            small = nano / 1000;\n        } else if (nano % 100 == 0) {\n            len += 8;\n            small = nano / 100;\n        } else if (nano % 10 == 0) {\n            len += 9;\n            small = nano / 10;\n        } else {\n            len += 10;\n            small = nano;\n        }\n        ensureCapacity(off + len);\n        bytes[off] = (byte) quote;\n        Arrays.fill(bytes, off + 1, off + len - 1, (byte) '0');\n        IOUtils.getChars(year, off + yearSize + 1, bytes);\n        bytes[off + yearSize + 1] = '-';\n        IOUtils.getChars(month, off + yearSize + 4, bytes);\n        bytes[off + yearSize + 4] = '-';\n        IOUtils.getChars(dayOfMonth, off + yearSize + 7, bytes);\n        bytes[off + yearSize + 7] = 'T';\n        IOUtils.getChars(hour, off + yearSize + 10, bytes);\n        bytes[off + yearSize + 10] = ':';\n        IOUtils.getChars(minute, off + yearSize + 13, bytes);\n        bytes[off + yearSize + 13] = ':';\n        IOUtils.getChars(second, off + yearSize + 16, bytes);\n        if (small != 0) {\n            bytes[off + yearSize + 16] = '.';\n            IOUtils.getChars(small, off + len - 1 - zoneSize, bytes);\n        }\n        if (zoneSize == 1) {\n            bytes[off + len - 2] = 'Z';\n        } else if (firstZoneChar == '+' || firstZoneChar == '-') {\n            zoneId.getBytes(0, zoneId.length(), bytes, off + len - zoneSize - 1);\n        } else {\n            bytes[off + len - zoneSize - 1] = '[';\n            zoneId.getBytes(0, zoneId.length(), bytes, off + len - zoneSize);\n            bytes[off + len - 2] = ']';\n        }\n        bytes[off + len - 1] = (byte) quote;\n        off += len;\n    }\n    @Override\n    public final void writeOffsetDateTime(OffsetDateTime dateTime) {\n        if (dateTime == null) {\n            writeNull();\n            return;\n        }\n        int year = dateTime.getYear();\n        int month = dateTime.getMonthValue();\n        int dayOfMonth = dateTime.getDayOfMonth();\n        int hour = dateTime.getHour();\n        int minute = dateTime.getMinute();\n        int second = dateTime.getSecond();\n        int nano = dateTime.getNano();\n        String zoneId = dateTime.getOffset().getId();\n        int len = 17;\n        char firstZoneChar = '\\0';\n        int zoneSize;\n        if (\"UTC\".equals(zoneId) || \"Z\".equals(zoneId)) {\n            zoneId = \"Z\";\n            zoneSize = 1;\n        } else if (zoneId.length() != 0 && ((firstZoneChar = zoneId.charAt(0)) == '+' || firstZoneChar == '-')) {\n+1, -1•core/src/main/java/com/alibaba/fastjson2/reader/ObjectReaderImplOffsetDateTime.java\n@@ -31,7 +31,7 @@ final class ObjectReaderImplOffsetDateTime\n    @Override\n    public Object readJSONBObject(JSONReader jsonReader, Type fieldType, Object fieldName, long features) {\n        return jsonReader.readZonedDateTime();\n        return readObject(jsonReader, fieldType, fieldName, features);\n    }\n    @Override\n+1•core/src/main/java/com/alibaba/fastjson2/util/DateUtils.java\n@@ -20,6 +20,7 @@ import static java.time.ZoneOffset.UTC;\npublic class DateUtils {\n    public static final ZoneId DEFAULT_ZONE_ID = ZoneId.systemDefault();\n    public static final String SHANGHAI_ZONE_ID_NAME = \"Asia/Shanghai\";\n    public static final String OFFSET_8_ZONE_ID_NAME = \"+08:00\";\n    public static final ZoneId SHANGHAI_ZONE_ID\n            = SHANGHAI_ZONE_ID_NAME.equals(DEFAULT_ZONE_ID.getId())\n            ? DEFAULT_ZONE_ID\n+1, -3•core/src/main/java/com/alibaba/fastjson2/writer/ObjectWriterImplOffsetDateTime.java\n@@ -5,7 +5,6 @@ import com.alibaba.fastjson2.codec.DateTimeCodec;\nimport java.lang.reflect.Type;\nimport java.time.OffsetDateTime;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Locale;\n@@ -92,8 +91,7 @@ final class ObjectWriterImplOffsetDateTime\n        }\n        if (formatter == null) {\n            ZonedDateTime zdt = odt.toZonedDateTime();\n            jsonWriter.writeZonedDateTime(zdt);\n            jsonWriter.writeOffsetDateTime(odt);\n            return;\n        }\n+4•core/src/test/java/com/alibaba/fastjson2/date/OffsetDateTimeTest.java\n@@ -1,6 +1,7 @@\npackage com.alibaba.fastjson2.date;\nimport com.alibaba.fastjson2.JSON;\nimport com.alibaba.fastjson2.JSONB;\nimport org.junit.jupiter.api.Test;\nimport java.time.OffsetDateTime;\n@@ -14,5 +15,8 @@ public class OffsetDateTimeTest {\n        String str = JSON.toJSONString(odt);\n        OffsetDateTime odt1 = JSON.parseObject(str, OffsetDateTime.class);\n        assertEquals(odt, odt1);\n        OffsetDateTime odt2 = JSONB.parseObject(JSONB.toBytes(odt), OffsetDateTime.class);\n        assertEquals(odt, odt2);\n    }\n}\n+11, -1•core/src/test/java/com/alibaba/fastjson2/time/DateTest.java\n@@ -72,7 +72,17 @@ public class DateTest {\n        jw.writeAny(\n                OffsetDateTime.of(1970, 1, 1, 0, 0, 0, 0, ZoneOffset.ofHours(0)));\n        assertEquals(\"\\\"1970-01-01T00:00Z\\\"\", jw.toString());\n        assertEquals(\"\\\"1970-01-01T00:00:00Z\\\"\", jw.toString());\n    }\n    @Test\n    public void testOffsetDateTimeUTF8() throws Exception {\n        JSONWriter jw = JSONWriter.ofUTF8();\n        jw.getContext().setZoneId(ZoneId.of(\"UTC+0\"));\n        jw.writeAny(\n                OffsetDateTime.of(1970, 1, 1, 0, 0, 0, 0, ZoneOffset.ofHours(0)));\n        assertEquals(\"\\\"1970-01-01T00:00:00Z\\\"\", jw.toString());\n    }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 13329501619.0,
        "Patch": "1494,6 +1494,66 @@ public interface JSON {\n        }\n    }\n    /**\n     * Parses the json byte array as {@link T}. Returns\n     * {@code null} if received byte array is {@code null} or empty.\n     *\n     * @param chars the specified chars\n     * @param objectClass the specified actual type of {@link T}\n     * @param features the specified features is applied to parsing\n     * @return {@link T} or {@code null}\n     * @throws JSONException If a parsing error occurs\n     */\n    @SuppressWarnings(\"unchecked\")\n    static <T> T parseObject(char[] chars, Class<T> objectClass, JSONReader.Feature... features) {\n        if (chars == null || chars.length == 0) {\n            return null;\n        }\n        try (JSONReader reader = JSONReader.of(chars)) {\n            reader.context.config(features);\n            ObjectReader<T> objectReader = reader.getObjectReader(objectClass);\n            T object = objectReader.readObject(reader, objectClass, null, 0);\n            if (reader.resolveTasks != null) {\n                reader.handleResolveTasks(object);\n            }\n            if (reader.ch != EOI && (reader.context.features & IgnoreCheckClose.mask) == 0) {\n                throw new JSONException(reader.info(\"input not end\"));\n            }\n            return object;\n        }\n    }\n    /**\n     * Parses the json byte array as {@link T}. Returns\n     * {@code null} if received byte array is {@code null} or empty.\n     *\n     * @param chars the specified chars\n     * @param type the specified actual type of {@link T}\n     * @param features the specified features is applied to parsing\n     * @return {@link T} or {@code null}\n     * @throws JSONException If a parsing error occurs\n     */\n    @SuppressWarnings(\"unchecked\")\n    static <T> T parseObject(char[] chars, Type type, JSONReader.Feature... features) {\n        if (chars == null || chars.length == 0) {\n            return null;\n        }\n        try (JSONReader reader = JSONReader.of(chars)) {\n            reader.context.config(features);\n            ObjectReader<T> objectReader = reader.getObjectReader(type);\n            T object = objectReader.readObject(reader, type, null, 0);\n            if (reader.resolveTasks != null) {\n                reader.handleResolveTasks(object);\n            }\n            if (reader.ch != EOI && (reader.context.features & IgnoreCheckClose.mask) == 0) {\n                throw new JSONException(reader.info(\"input not end\"));\n            }\n            return object;\n        }\n    }\n    /**\n     * Parses the json byte array as {@link T}. Returns\n     * {@code null} if received byte array is {@code null} or empty.\n+8, -3•core/src/main/java/com/alibaba/fastjson2/JSONReader.java\n@@ -285,7 +285,7 @@ public abstract class JSONReader\n        return null;\n    }\n    static char char1(int c) {\n    final char char1(int c) {\n        switch (c) {\n            case '0':\n                return '\\0';\n@@ -328,9 +328,10 @@ public abstract class JSONReader\n            case '@':\n            case '(':\n            case ')':\n            case '_':\n                return (char) c;\n            default:\n                throw new JSONException(\"unclosed.str.lit \" + (char) c);\n                throw new JSONException(info(\"unclosed.str '\\\\\" + (char) c));\n        }\n    }\n@@ -1667,7 +1668,11 @@ public abstract class JSONReader\n            Object name;\n            if (match || typeRedirect) {\n                name = readFieldName();\n                if (ch >= '1' && ch <= '9') {\n                    name = null;\n                } else {\n                    name = readFieldName();\n                }\n            } else {\n                name = getFieldName();\n                match = true;\n+5, -1•core/src/main/java/com/alibaba/fastjson2/JSONReaderASCII.java\n@@ -859,6 +859,10 @@ class JSONReaderASCII\n    @Override\n    public final String readFieldName() {\n        if (ch != '\"' && ch != '\\'') {\n            if ((context.features & Feature.AllowUnQuotedFieldNames.mask) != 0 && isFirstIdentifier(ch)) {\n                return readFieldNameUnquote();\n            }\n            return null;\n        }\n@@ -1495,7 +1499,7 @@ class JSONReaderASCII\n                return null;\n            }\n            default:\n                throw new JSONException(\"TODO : \" + ch);\n                throw new JSONException(info(\"illegal input : \" + ch));\n        }\n    }\n}\n+7, -8•core/src/main/java/com/alibaba/fastjson2/JSONReaderUTF16.java\n@@ -378,13 +378,8 @@ class JSONReaderUTF16\n            next();\n        }\n        while (ch == '/') {\n            next();\n            if (ch == '/') {\n                skipLineComment();\n            } else {\n                throw new JSONException(\"input not support \" + ch + \", offset \" + offset);\n            }\n        while (ch == '/' && this.offset < this.chars.length && this.chars[this.offset] == '/') {\n            skipLineComment();\n        }\n    }\n@@ -1731,6 +1726,10 @@ class JSONReaderUTF16\n        }\n        if (ch != '\"' && ch != '\\'') {\n            if ((context.features & Feature.AllowUnQuotedFieldNames.mask) != 0 && isFirstIdentifier(ch)) {\n                return readFieldNameUnquote();\n            }\n            return null;\n        }\n@@ -3828,7 +3827,7 @@ class JSONReaderUTF16\n                return null;\n            }\n            default:\n                throw new JSONException(\"TODO : \" + ch);\n                throw new JSONException(info(\"illegal input : \" + ch));\n        }\n    }\n+11, -22•core/src/main/java/com/alibaba/fastjson2/JSONReaderUTF8.java\n@@ -68,13 +68,8 @@ class JSONReaderUTF8\n        this.end = length;\n        next();\n        while (ch == '/') {\n            next();\n            if (ch == '/') {\n                skipLineComment();\n            } else {\n                throw new JSONException(\"input not support \" + ch + \", offset \" + offset);\n            }\n        while (ch == '/' && this.offset < this.bytes.length && this.bytes[this.offset] == '/') {\n            skipLineComment();\n        }\n    }\n@@ -98,13 +93,8 @@ class JSONReaderUTF8\n        this.end = length;\n        next();\n        while (ch == '/') {\n            next();\n            if (ch == '/') {\n                skipLineComment();\n            } else {\n                throw new JSONException(\"input not support \" + ch + \", offset \" + offset);\n            }\n        while (ch == '/' && this.offset < this.bytes.length && this.bytes[this.offset] == '/') {\n            skipLineComment();\n        }\n    }\n@@ -120,13 +110,8 @@ class JSONReaderUTF8\n        this.cacheItem = null;\n        next();\n        while (ch == '/') {\n            next();\n            if (ch == '/') {\n                skipLineComment();\n            } else {\n                throw new JSONException(\"input not support \" + ch + \", offset \" + offset);\n            }\n        while (ch == '/' && this.offset < this.bytes.length && this.bytes[this.offset] == '/') {\n            skipLineComment();\n        }\n    }\n@@ -1448,6 +1433,10 @@ class JSONReaderUTF8\n    @Override\n    public String readFieldName() {\n        if (ch != '\"' && ch != '\\'') {\n            if ((context.features & Feature.AllowUnQuotedFieldNames.mask) != 0 && isFirstIdentifier(ch)) {\n                return readFieldNameUnquote();\n            }\n            return null;\n        }\n@@ -4029,7 +4018,7 @@ class JSONReaderUTF8\n                return null;\n            }\n            default:\n                throw new JSONException(\"TODO : \" + ch);\n                throw new JSONException(info(\"illegal input : \" + ch));\n        }\n    }\n+41•/dev/null → core/src/test/java/com/alibaba/fastjson2/read/ObjectKeyTest.java\n@@ -0,0 +1,41 @@\npackage com.alibaba.fastjson2.read;\nimport com.alibaba.fastjson2.JSON;\nimport com.alibaba.fastjson2.JSONReader;\nimport org.junit.jupiter.api.Test;\nimport java.lang.reflect.Type;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\npublic class ObjectKeyTest {\n    @Test\n    public void test() {\n        assertEquals(1, JSON.parseObject(\"{\\\"items\\\":{{}:{\\\"id\\\":123}}}\", Bean.class).items.size());\n        assertEquals(1, JSON.parseObject(\"{\\\"items\\\":{1:{\\\"id\\\":123}}}\", Bean.class).items.size());\n        assertEquals(1, JSON.parseObject(\"{\\\"items\\\":{true:{\\\"id\\\":123}}}\", Bean.class).items.size());\n        assertEquals(1, JSON.parseObject(\"{\\\"items\\\":{false:{\\\"id\\\":123}}}\", Bean.class).items.size());\n        assertEquals(1, JSON.parseObject(\"{\\\"items\\\":{null:{\\\"id\\\":123}}}\", Bean.class).items.size());\n    }\n    @Test\n    public void test1() {\n        String s = \"{items:{k1:{id:123}}}\";\n        assertEquals(1, JSON.parseObject(s, Bean.class, JSONReader.Feature.AllowUnQuotedFieldNames).items.size());\n        byte[] bytes = s.getBytes();\n        assertEquals(1, JSON.parseObject(bytes, 0, bytes.length, StandardCharsets.UTF_8, Bean.class, JSONReader.Feature.AllowUnQuotedFieldNames).items.size());\n        assertEquals(1, JSON.parseObject(bytes, Bean.class, JSONReader.Feature.AllowUnQuotedFieldNames).items.size());\n        assertEquals(1, JSON.parseObject(s.toCharArray(), Bean.class, JSONReader.Feature.AllowUnQuotedFieldNames).items.size());\n        assertEquals(1, ((Bean) JSON.parseObject(s.toCharArray(), (Type) Bean.class, JSONReader.Feature.AllowUnQuotedFieldNames)).items.size());\n    }\n    public static class Bean {\n        public Map<String, Item> items;\n    }\n    public static class Item {\n        public int id;\n    }\n}\n+82•core/src/test/java/com/alibaba/fastjson2/v1issues/issue_3600/Issue3689.java\n@@ -19,6 +19,12 @@ public class Issue3689 {\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"/dfdfdf\");\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"/dfdfdf\".getBytes());\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"/dfdfdf\".toCharArray());\n        });\n    }\n    @Test\n@@ -26,6 +32,12 @@ public class Issue3689 {\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"//dfdfdf\");\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"//dfdfdf\".getBytes());\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"//dfdfdf\".toCharArray());\n        });\n    }\n    @Test\n@@ -33,6 +45,12 @@ public class Issue3689 {\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"///dfdfdf\");\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"///dfdfdf\".getBytes());\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"///dfdfdf\".toCharArray());\n        });\n    }\n    @Test\n@@ -40,6 +58,12 @@ public class Issue3689 {\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"////dfdfdf\");\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"////dfdfdf\".getBytes());\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"////dfdfdf\".toCharArray());\n        });\n    }\n    @Test\n@@ -47,6 +71,12 @@ public class Issue3689 {\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"/////dfdfdf\");\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"/////dfdfdf\".getBytes());\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"/////dfdfdf\".toCharArray());\n        });\n    }\n    @Test\n@@ -54,6 +84,12 @@ public class Issue3689 {\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"//////dfdfdf\");\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"//////dfdfdf\".getBytes());\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"//////dfdfdf\".toCharArray());\n        });\n    }\n    @Test\n@@ -61,6 +97,12 @@ public class Issue3689 {\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"dfdfdf\", String.class);\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"dfdfdf\".getBytes(), String.class);\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"dfdfdf\".toCharArray(), String.class);\n        });\n    }\n    @Test\n@@ -68,6 +110,12 @@ public class Issue3689 {\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"/dfdfdf\", String.class);\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"/dfdfdf\".getBytes(), String.class);\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"/dfdfdf\".toCharArray(), String.class);\n        });\n    }\n    @Test\n@@ -75,6 +123,12 @@ public class Issue3689 {\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"//dfdfdf\", String.class);\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"//dfdfdf\".getBytes(), String.class);\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"//dfdfdf\".toCharArray(), String.class);\n        });\n    }\n    @Test\n@@ -82,6 +136,12 @@ public class Issue3689 {\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"///dfdfdf\", String.class);\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"///dfdfdf\".getBytes(), String.class);\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"///dfdfdf\".toCharArray(), String.class);\n        });\n    }\n    @Test\n@@ -89,6 +149,12 @@ public class Issue3689 {\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"////dfdfdf\", String.class);\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"////dfdfdf\".getBytes(), String.class);\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"////dfdfdf\".toCharArray(), String.class);\n        });\n    }\n    @Test\n@@ -96,6 +162,12 @@ public class Issue3689 {\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"/////dfdfdf\", String.class);\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"/////dfdfdf\".getBytes(), String.class);\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"/////dfdfdf\".toCharArray(), String.class);\n        });\n    }\n    @Test\n@@ -103,11 +175,21 @@ public class Issue3689 {\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"//////dfdfdf\", String.class);\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"//////dfdfdf\".getBytes(), String.class);\n        });\n        assertThrows(JSONException.class, () -> {\n            JSON.parseArray(\"//////dfdfdf\".toCharArray(), String.class);\n        });\n    }\n    @Test\n    public void test_for_issue() {\n        JSON.parseArray(\"[\\\"////dfdfdf\\\"]\"); //不会抛异常\n        JSON.parseArray(\"[\\\"////dfdfdf\\\"]\".getBytes()); //不会抛异常\n        JSON.parseArray(\"[\\\"////dfdfdf\\\"]\".toCharArray()); //不会抛异常\n        JSON.parse(\"[\\\"dfdfdf\\\"]\"); //不会抛异常\n        JSON.parse(\"[\\\"dfdfdf\\\"]\".getBytes()); //不会抛异常\n        JSON.parse(\"[\\\"dfdfdf\\\"]\".toCharArray()); //不会抛异常\n    }\n}\n+1, -1•fastjson1-compatible/src/test/java/com/alibaba/fastjson/issue_3600/Issue3689.java\n@@ -16,7 +16,7 @@ public class Issue3689 {\n    @Test\n    public void test_without_type_1_meaningles_char() {\n        assertThrows(com.alibaba.fastjson2.JSONException.class, () -> {\n        assertThrows(com.alibaba.fastjson.JSONException.class, () -> {\n            JSONArray.parseArray(\"/dfdfdf\");\n        });\n    }\n+31•/dev/null → fastjson1-compatible/src/test/java/com/alibaba/fastjson/parser/UnquoteStringKeyTest.java\n@@ -0,0 +1,31 @@\npackage com.alibaba.fastjson.parser;\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport org.junit.jupiter.api.Test;\nimport java.util.Map;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\npublic class UnquoteStringKeyTest {\n    @Test\n    public void test() {\n        String str = \"{name: \\\"xx\\\",displayName: \\\"xxx\\\",description: \\\"x\\\",algorithmType: 0,usingType: 0,adminClass: \\\"x\\\",workingClass: \\\"x\\\",generationMeta:{keyLength: {displayName: \\\"x\\\",description: \\\"x\\\",allowInput: \\\"false\\\",valueType: \\\"int\\\",validValues: [\\\"128\\\",\\\"192\\\",\\\"256\\\"],defaultValue: \\\"256\\\"}},workingMeta:{workMode: {displayName: \\\"x\\\",description: \\\"x\\\",allowInput: \\\"false\\\",valueType: \\\"string\\\",validValues: [\\\"ECB\\\", \\\"CBC\\\", \\\"CFB\\\", \\\"OFB\\\", \\\"GCM\\\"],defaultValue: \\\"x\\\"},padding: {displayName: \\\"x\\\",description: \\\"x\\\",allowInput: \\\"false\\\",valueType: \\\"string\\\",validValues: [\\\"x\\\", \\\"x\\\", \\\"x\\\"],defaultValue: \\\"x\\\"},initVector: {displayName: \\\"初\\\",description: \\\"x\\\",allowInput: \\\"false\\\",valueType: \\\"string\\\",validValues: [\\\"x\\\", \\\"x\\\", \\\"x\\\"],defaultValue: \\\"x\\\"}}}\";\n        JSONObject object = JSON.parseObject(str);\n        assertEquals(\"xx\", object.get(\"name\"));\n    }\n    @Test\n    public void test1() {\n        assertEquals(1, JSON.parseObject(\"{items:{k1:{id:123}}}\", Bean.class).items.size());\n    }\n    public static class Bean {\n        public Map<String, Item> items;\n    }\n    public static class Item {\n        public int id;\n    }\n}\n+1, -1•incubator-vector/src/main/java/com/alibaba/fastjson2/JSONReaderUTF16Vector.java\n@@ -217,7 +217,7 @@ final class JSONReaderUTF16Vector\n                return null;\n            }\n            default:\n                throw new JSONException(\"TODO : \" + ch);\n                throw new JSONException(info(\"illegal input : \" + ch));\n        }\n    }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 25672852002.0,
        "Patch": "70,10 +70,16 @@ public class ObjectReaderImplDate\n        }\n        long millis;\n        if (useSimpleFormatter) {\n        if (useSimpleFormatter || locale != null) {\n            String str = jsonReader.readString();\n            try {\n                return new SimpleDateFormat(format).parse(str);\n                SimpleDateFormat dateFormat;\n                if (locale != null) {\n                    dateFormat = new SimpleDateFormat(format, locale);\n                } else {\n                    dateFormat = new SimpleDateFormat(format);\n                }\n                return dateFormat.parse(str);\n            } catch (ParseException e) {\n                throw new JSONException(jsonReader.info(\"parse error : \" + str), e);\n            }\n+5, -5•core/src/test/java/com/alibaba/fastjson2/jackson_support/JsonFormatTest.java\n@@ -130,15 +130,15 @@ public class JsonFormatTest {\n        String fastjson = JSON.toJSONString(bean);\n        String jackson = objectMapper.writeValueAsString(bean);\n        assertEquals(jackson, fastjson);\n//\n//        Bean6 parsed0 = objectMapper.readValue(jackson, Bean6.class);\n//        Bean6 parsed1 = JSON.parseObject(fastjson, Bean6.class);\n//        assertEquals(parsed0.time.getTime(), parsed1.time.getTime());\n        Bean6 parsed0 = objectMapper.readValue(jackson, Bean6.class);\n        Bean6 parsed1 = JSON.parseObject(fastjson, Bean6.class);\n        assertEquals(parsed0.time.getTime(), parsed1.time.getTime());\n    }\n    @Data\n    public static class Bean6 {\n        @JsonFormat(pattern = \"yyyy-MM-dd\", locale = \"zh_CN\")\n        @JsonFormat(pattern = \"yyyy-MM-dd\", locale = \"zh-CN\", timezone = \"Asia/Shanghai\")\n        private Date time;\n    }\n}",
        "Label": "NPE_Fix"
    },
    {
        "ID": 25672852105.0,
        "Patch": "public class ObjectReaderImplDate\n        }\n        long millis;\n        if (useSimpleFormatter) {\n        if (useSimpleFormatter || locale != null) {\n            String str = jsonReader.readString();\n            try {\n                return new SimpleDateFormat(format).parse(str);\n                SimpleDateFormat dateFormat;\n                if (locale != null) {\n                    dateFormat = new SimpleDateFormat(format, locale);\n                } else {\n                    dateFormat = new SimpleDateFormat(format);\n                }\n                return dateFormat.parse(str);\n            } catch (ParseException e) {\n                throw new JSONException(jsonReader.info(\"parse error : \" + str), e);\n            }\n+5, -5•core/src/test/java/com/alibaba/fastjson2/jackson_support/JsonFormatTest.java\n@@ -130,15 +130,15 @@ public class JsonFormatTest {\n        String fastjson = JSON.toJSONString(bean);\n        String jackson = objectMapper.writeValueAsString(bean);\n        assertEquals(jackson, fastjson);\n//\n//        Bean6 parsed0 = objectMapper.readValue(jackson, Bean6.class);\n//        Bean6 parsed1 = JSON.parseObject(fastjson, Bean6.class);\n//        assertEquals(parsed0.time.getTime(), parsed1.time.getTime());\n        Bean6 parsed0 = objectMapper.readValue(jackson, Bean6.class);\n        Bean6 parsed1 = JSON.parseObject(fastjson, Bean6.class);\n        assertEquals(parsed0.time.getTime(), parsed1.time.getTime());\n    }\n    @Data\n    public static class Bean6 {\n        @JsonFormat(pattern = \"yyyy-MM-dd\", locale = \"zh_CN\")\n        @JsonFormat(pattern = \"yyyy-MM-dd\", locale = \"zh-CN\", timezone = \"Asia/Shanghai\")\n        private Date time;\n    }\n}",
        "Label": "NPE_Fix"
    },
    {
        "ID": 29210964518.0,
        "Patch": "2270,6 +2270,10 @@ public abstract class JSONReader\n                if (ch == '-' || (ch >= '0' && ch <= '9')) {\n                    readNumber0();\n                    name = getNumber();\n                } else if (ch == '{') {\n                    name = readObject();\n                } else if (ch == '[') {\n                    name = readArray();\n                } else {\n                    name = readFieldNameUnquote();\n                }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 29210964592.0,
        "Patch": "public abstract class JSONReader\n                if (ch == '-' || (ch >= '0' && ch <= '9')) {\n                    readNumber0();\n                    name = getNumber();\n                } else if (ch == '{') {\n                    name = readObject();\n                } else if (ch == '[') {\n                    name = readArray();\n                } else {\n                    name = readFieldNameUnquote();\n                }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 29546810757.0,
        "Patch": "class FieldReaderCollectionMethodReadOnly<T>\n        if (\"java.util.Collections$UnmodifiableRandomAccessList\".equals(name)\n                || \"java.util.Arrays$ArrayList\".equals(name)\n                || \"java.util.Collections$SingletonList\".equals(name)\n                || name.startsWith(\"java.util.ImmutableCollections$\")) {\n                || name.startsWith(\"java.util.ImmutableCollections$\")\n                || name.startsWith(\"java.util.Collections$Unmodifiable\")) {\n            return;\n        }\n+1, -1•core/src/main/java/com/alibaba/fastjson2/reader/ObjectReaderNoneDefaultConstructor.java\n@@ -360,7 +360,7 @@ public class ObjectReaderNoneDefaultConstructor<T>\n                Object fieldValue = valueMap.get(fieldReader.fieldNameHash);\n                if (fieldValue != null) {\n                    if (paramReader != null) {\n                    if (paramReader != null && (paramReader.fieldName == null || fieldReader.fieldName == null || !paramReader.fieldName.equals(fieldReader.fieldName))) {\n                        continue;\n                    }\n                    fieldReader.accept(object, fieldValue);\n+3, -2•core/src/main/java/com/alibaba/fastjson2/writer/ObjectWriterBaseModule.java\n@@ -769,11 +769,12 @@ public class ObjectWriterBaseModule\n            if (objectClass != null) {\n                Class superclass = objectClass.getSuperclass();\n                Method supperMethod = BeanUtils.getMethod(superclass, method);\n                boolean ignore = fieldInfo.ignore;\n                if (supperMethod != null) {\n                    getFieldInfo(beanInfo, fieldInfo, superclass, supperMethod);\n                    boolean ignore = fieldInfo.ignore;\n                    Field field = BeanUtils.getField(objectClass, method);\n                    int supperMethodModifiers = supperMethod.getModifiers();\n                    if (ignore != fieldInfo.ignore\n                    if (null != field && ignore != fieldInfo.ignore\n                            && !Modifier.isAbstract(supperMethodModifiers)\n                            && !supperMethod.equals(method)\n                    ) {\n+1, -1•core/src/main/java/com/alibaba/fastjson2/writer/ObjectWriterCreatorASM.java\n@@ -217,7 +217,7 @@ public class ObjectWriterCreatorASM\n                if (!record) {\n                    BeanUtils.declaredFields(objectClass, field -> {\n                        fieldInfo.init();\n                        fieldInfo.ignore = (field.getModifiers() & Modifier.PUBLIC) == 0 || (field.getModifiers() & Modifier.TRANSIENT) != 0;\n                        fieldInfo.ignore = ((field.getModifiers() & Modifier.PUBLIC) == 0 || (field.getModifiers() & Modifier.TRANSIENT) != 0);\n                        FieldWriter fieldWriter = creteFieldWriter(objectClass, writerFieldFeatures, provider, beanInfo, fieldInfo, field);\n                        if (fieldWriter != null) {\n+35•/dev/null → core/src/test/java/com/alibaba/fastjson2/issues_2900/Issue2901.java\n@@ -0,0 +1,35 @@\npackage com.alibaba.fastjson2.issues_2900;\nimport com.alibaba.fastjson2.JSONObject;\nimport com.alibaba.fastjson2.annotation.JSONField;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\nimport static org.junit.jupiter.api.Assertions.*;\npublic class Issue2901 {\n    @Setter\n    @Getter\n    @AllArgsConstructor\n    public class User {\n        @JSONField(name = \"user_name\")\n        private String userName;\n        @Override\n        public String toString() {\n            return \"User{\" +\n                    \"userName='\" + userName + '\\'' +\n                    '}';\n        }\n    }\n    void test() {\n        String str1 = \"{\\n\" +\n                \"\\\"user_name\\\":\\\"zs\\\"\\n\" +\n                \"}\";\n        User user = JSONObject.parseObject(str1, User.class);\n        assertNotNull(user);\n        assertEquals(user.getUserName(), \"zs\");\n    }\n}",
        "Label": "NPE_Fix"
    },
    {
        "ID": 29546810957.0,
        "Patch": "core/src/main/java/com/alibaba/fastjson2/reader/FieldReaderCollectionMethodReadOnly.java\n@@ -65,7 +65,8 @@ class FieldReaderCollectionMethodReadOnly<T>\n        if (\"java.util.Collections$UnmodifiableRandomAccessList\".equals(name)\n                || \"java.util.Arrays$ArrayList\".equals(name)\n                || \"java.util.Collections$SingletonList\".equals(name)\n                || name.startsWith(\"java.util.ImmutableCollections$\")) {\n                || name.startsWith(\"java.util.ImmutableCollections$\")\n                || name.startsWith(\"java.util.Collections$Unmodifiable\")) {\n            return;\n        }\n+1, -1•core/src/main/java/com/alibaba/fastjson2/reader/ObjectReaderNoneDefaultConstructor.java\n@@ -360,7 +360,7 @@ public class ObjectReaderNoneDefaultConstructor<T>\n                Object fieldValue = valueMap.get(fieldReader.fieldNameHash);\n                if (fieldValue != null) {\n                    if (paramReader != null) {\n                    if (paramReader != null && (paramReader.fieldName == null || fieldReader.fieldName == null || !paramReader.fieldName.equals(fieldReader.fieldName))) {\n                        continue;\n                    }\n                    fieldReader.accept(object, fieldValue);\n+3, -2•core/src/main/java/com/alibaba/fastjson2/writer/ObjectWriterBaseModule.java\n@@ -769,11 +769,12 @@ public class ObjectWriterBaseModule\n            if (objectClass != null) {\n                Class superclass = objectClass.getSuperclass();\n                Method supperMethod = BeanUtils.getMethod(superclass, method);\n                boolean ignore = fieldInfo.ignore;\n                if (supperMethod != null) {\n                    getFieldInfo(beanInfo, fieldInfo, superclass, supperMethod);\n                    boolean ignore = fieldInfo.ignore;\n                    Field field = BeanUtils.getField(objectClass, method);\n                    int supperMethodModifiers = supperMethod.getModifiers();\n                    if (ignore != fieldInfo.ignore\n                    if (null != field && ignore != fieldInfo.ignore\n                            && !Modifier.isAbstract(supperMethodModifiers)\n                            && !supperMethod.equals(method)\n                    ) {\n+1, -1•core/src/main/java/com/alibaba/fastjson2/writer/ObjectWriterCreatorASM.java\n@@ -217,7 +217,7 @@ public class ObjectWriterCreatorASM\n                if (!record) {\n                    BeanUtils.declaredFields(objectClass, field -> {\n                        fieldInfo.init();\n                        fieldInfo.ignore = (field.getModifiers() & Modifier.PUBLIC) == 0 || (field.getModifiers() & Modifier.TRANSIENT) != 0;\n                        fieldInfo.ignore = ((field.getModifiers() & Modifier.PUBLIC) == 0 || (field.getModifiers() & Modifier.TRANSIENT) != 0);\n                        FieldWriter fieldWriter = creteFieldWriter(objectClass, writerFieldFeatures, provider, beanInfo, fieldInfo, field);\n                        if (fieldWriter != null) {\n+35•/dev/null → core/src/test/java/com/alibaba/fastjson2/issues_2900/Issue2901.java\n@@ -0,0 +1,35 @@\npackage com.alibaba.fastjson2.issues_2900;\nimport com.alibaba.fastjson2.JSONObject;\nimport com.alibaba.fastjson2.annotation.JSONField;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\nimport static org.junit.jupiter.api.Assertions.*;\npublic class Issue2901 {\n    @Setter\n    @Getter\n    @AllArgsConstructor\n    public class User {\n        @JSONField(name = \"user_name\")\n        private String userName;\n        @Override\n        public String toString() {\n            return \"User{\" +\n                    \"userName='\" + userName + '\\'' +\n                    '}';\n        }\n    }\n    void test() {\n        String str1 = \"{\\n\" +\n                \"\\\"user_name\\\":\\\"zs\\\"\\n\" +\n                \"}\";\n        User user = JSONObject.parseObject(str1, User.class);\n        assertNotNull(user);\n        assertEquals(user.getUserName(), \"zs\");\n    }\n}",
        "Label": "NPE_Fix"
    },
    {
        "ID": 35038563427.0,
        "Patch": "7,6 +7,8 @@ import com.alibaba.fastjson2.util.Fnv;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n@@ -139,6 +141,7 @@ final class ObjectReaderSeeAlso<T>\n            }\n        }\n        Map<Long, Object> fieldValues = null;\n        for (int i = 0; ; i++) {\n            if (jsonReader.nextIfObjectEnd()) {\n                if (object == null) {\n@@ -239,9 +242,6 @@ final class ObjectReaderSeeAlso<T>\n            if (object == null) {\n                object = createInstance(jsonReader.getContext().getFeatures() | features);\n                if (object == null) {\n                    throw new JSONException(\"create instance error, objectClass : \" + objectClass);\n                }\n            }\n            if (fieldReader == null) {\n@@ -249,7 +249,22 @@ final class ObjectReaderSeeAlso<T>\n                continue;\n            }\n            fieldReader.readFieldValue(jsonReader, object);\n            if (object == null) {\n                Object fieldValue = fieldReader.readFieldValue(jsonReader);\n                if (fieldValues == null) {\n                    fieldValues = new LinkedHashMap<>();\n                }\n                fieldValues.put(hash, fieldValue);\n            } else {\n                fieldReader.readFieldValue(jsonReader, object);\n            }\n        }\n        if (fieldValues != null) {\n            for (Map.Entry<Long, Object> entry : fieldValues.entrySet()) {\n                FieldReader fieldReader = getFieldReader(entry.getKey());\n                fieldReader.accept(object, entry.getValue());\n            }\n        }\n        jsonReader.nextIfComma();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 35038563619.0,
        "Patch": "src/main/java/com/alibaba/fastjson2/reader/ObjectReaderSeeAlso.java\n@@ -7,6 +7,8 @@ import com.alibaba.fastjson2.util.Fnv;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n@@ -139,6 +141,7 @@ final class ObjectReaderSeeAlso<T>\n            }\n        }\n        Map<Long, Object> fieldValues = null;\n        for (int i = 0; ; i++) {\n            if (jsonReader.nextIfObjectEnd()) {\n                if (object == null) {\n@@ -239,9 +242,6 @@ final class ObjectReaderSeeAlso<T>\n            if (object == null) {\n                object = createInstance(jsonReader.getContext().getFeatures() | features);\n                if (object == null) {\n                    throw new JSONException(\"create instance error, objectClass : \" + objectClass);\n                }\n            }\n            if (fieldReader == null) {\n@@ -249,7 +249,22 @@ final class ObjectReaderSeeAlso<T>\n                continue;\n            }\n            fieldReader.readFieldValue(jsonReader, object);\n            if (object == null) {\n                Object fieldValue = fieldReader.readFieldValue(jsonReader);\n                if (fieldValues == null) {\n                    fieldValues = new LinkedHashMap<>();\n                }\n                fieldValues.put(hash, fieldValue);\n            } else {\n                fieldReader.readFieldValue(jsonReader, object);\n            }\n        }\n        if (fieldValues != null) {\n            for (Map.Entry<Long, Object> entry : fieldValues.entrySet()) {\n                FieldReader fieldReader = getFieldReader(entry.getKey());\n                fieldReader.accept(object, entry.getValue());\n            }\n        }\n        jsonReader.nextIfComma();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 35038563780.0,
        "Patch": "import com.alibaba.fastjson2.util.Fnv;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n@@ -139,6 +141,7 @@ final class ObjectReaderSeeAlso<T>\n            }\n        }\n        Map<Long, Object> fieldValues = null;\n        for (int i = 0; ; i++) {\n            if (jsonReader.nextIfObjectEnd()) {\n                if (object == null) {\n@@ -239,9 +242,6 @@ final class ObjectReaderSeeAlso<T>\n            if (object == null) {\n                object = createInstance(jsonReader.getContext().getFeatures() | features);\n                if (object == null) {\n                    throw new JSONException(\"create instance error, objectClass : \" + objectClass);\n                }\n            }\n            if (fieldReader == null) {\n@@ -249,7 +249,22 @@ final class ObjectReaderSeeAlso<T>\n                continue;\n            }\n            fieldReader.readFieldValue(jsonReader, object);\n            if (object == null) {\n                Object fieldValue = fieldReader.readFieldValue(jsonReader);\n                if (fieldValues == null) {\n                    fieldValues = new LinkedHashMap<>();\n                }\n                fieldValues.put(hash, fieldValue);\n            } else {\n                fieldReader.readFieldValue(jsonReader, object);\n            }\n        }\n        if (fieldValues != null) {\n            for (Map.Entry<Long, Object> entry : fieldValues.entrySet()) {\n                FieldReader fieldReader = getFieldReader(entry.getKey());\n                fieldReader.accept(object, entry.getValue());\n            }\n        }\n        jsonReader.nextIfComma();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 35038563954.0,
        "Patch": "java/com/alibaba/fastjson2/reader/ObjectReaderSeeAlso.java\n@@ -7,6 +7,8 @@ import com.alibaba.fastjson2.util.Fnv;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n@@ -139,6 +141,7 @@ final class ObjectReaderSeeAlso<T>\n            }\n        }\n        Map<Long, Object> fieldValues = null;\n        for (int i = 0; ; i++) {\n            if (jsonReader.nextIfObjectEnd()) {\n                if (object == null) {\n@@ -239,9 +242,6 @@ final class ObjectReaderSeeAlso<T>\n            if (object == null) {\n                object = createInstance(jsonReader.getContext().getFeatures() | features);\n                if (object == null) {\n                    throw new JSONException(\"create instance error, objectClass : \" + objectClass);\n                }\n            }\n            if (fieldReader == null) {\n@@ -249,7 +249,22 @@ final class ObjectReaderSeeAlso<T>\n                continue;\n            }\n            fieldReader.readFieldValue(jsonReader, object);\n            if (object == null) {\n                Object fieldValue = fieldReader.readFieldValue(jsonReader);\n                if (fieldValues == null) {\n                    fieldValues = new LinkedHashMap<>();\n                }\n                fieldValues.put(hash, fieldValue);\n            } else {\n                fieldReader.readFieldValue(jsonReader, object);\n            }\n        }\n        if (fieldValues != null) {\n            for (Map.Entry<Long, Object> entry : fieldValues.entrySet()) {\n                FieldReader fieldReader = getFieldReader(entry.getKey());\n                fieldReader.accept(object, entry.getValue());\n            }\n        }\n        jsonReader.nextIfComma();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 35038707310.0,
        "Patch": "6 +7,8 @@ import com.alibaba.fastjson2.util.Fnv;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n@@ -139,6 +141,7 @@ final class ObjectReaderSeeAlso<T>\n            }\n        }\n        Map<Long, Object> fieldValues = null;\n        for (int i = 0; ; i++) {\n            if (jsonReader.nextIfObjectEnd()) {\n                if (object == null) {\n@@ -239,9 +242,6 @@ final class ObjectReaderSeeAlso<T>\n            if (object == null) {\n                object = createInstance(jsonReader.getContext().getFeatures() | features);\n                if (object == null) {\n                    throw new JSONException(\"create instance error, objectClass : \" + objectClass);\n                }\n            }\n            if (fieldReader == null) {\n@@ -249,7 +249,22 @@ final class ObjectReaderSeeAlso<T>\n                continue;\n            }\n            fieldReader.readFieldValue(jsonReader, object);\n            if (object == null) {\n                Object fieldValue = fieldReader.readFieldValue(jsonReader);\n                if (fieldValues == null) {\n                    fieldValues = new LinkedHashMap<>();\n                }\n                fieldValues.put(hash, fieldValue);\n            } else {\n                fieldReader.readFieldValue(jsonReader, object);\n            }\n        }\n        if (fieldValues != null) {\n            for (Map.Entry<Long, Object> entry : fieldValues.entrySet()) {\n                FieldReader fieldReader = getFieldReader(entry.getKey());\n                fieldReader.accept(object, entry.getValue());\n            }\n        }\n        jsonReader.nextIfComma();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 35038707417.0,
        "Patch": "core/src/main/java/com/alibaba/fastjson2/reader/ObjectReaderSeeAlso.java\n@@ -7,6 +7,8 @@ import com.alibaba.fastjson2.util.Fnv;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n@@ -139,6 +141,7 @@ final class ObjectReaderSeeAlso<T>\n            }\n        }\n        Map<Long, Object> fieldValues = null;\n        for (int i = 0; ; i++) {\n            if (jsonReader.nextIfObjectEnd()) {\n                if (object == null) {\n@@ -239,9 +242,6 @@ final class ObjectReaderSeeAlso<T>\n            if (object == null) {\n                object = createInstance(jsonReader.getContext().getFeatures() | features);\n                if (object == null) {\n                    throw new JSONException(\"create instance error, objectClass : \" + objectClass);\n                }\n            }\n            if (fieldReader == null) {\n@@ -249,7 +249,22 @@ final class ObjectReaderSeeAlso<T>\n                continue;\n            }\n            fieldReader.readFieldValue(jsonReader, object);\n            if (object == null) {\n                Object fieldValue = fieldReader.readFieldValue(jsonReader);\n                if (fieldValues == null) {\n                    fieldValues = new LinkedHashMap<>();\n                }\n                fieldValues.put(hash, fieldValue);\n            } else {\n                fieldReader.readFieldValue(jsonReader, object);\n            }\n        }\n        if (fieldValues != null) {\n            for (Map.Entry<Long, Object> entry : fieldValues.entrySet()) {\n                FieldReader fieldReader = getFieldReader(entry.getKey());\n                fieldReader.accept(object, entry.getValue());\n            }\n        }\n        jsonReader.nextIfComma();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 35038707531.0,
        "Patch": "import com.alibaba.fastjson2.util.Fnv;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n@@ -139,6 +141,7 @@ final class ObjectReaderSeeAlso<T>\n            }\n        }\n        Map<Long, Object> fieldValues = null;\n        for (int i = 0; ; i++) {\n            if (jsonReader.nextIfObjectEnd()) {\n                if (object == null) {\n@@ -239,9 +242,6 @@ final class ObjectReaderSeeAlso<T>\n            if (object == null) {\n                object = createInstance(jsonReader.getContext().getFeatures() | features);\n                if (object == null) {\n                    throw new JSONException(\"create instance error, objectClass : \" + objectClass);\n                }\n            }\n            if (fieldReader == null) {\n@@ -249,7 +249,22 @@ final class ObjectReaderSeeAlso<T>\n                continue;\n            }\n            fieldReader.readFieldValue(jsonReader, object);\n            if (object == null) {\n                Object fieldValue = fieldReader.readFieldValue(jsonReader);\n                if (fieldValues == null) {\n                    fieldValues = new LinkedHashMap<>();\n                }\n                fieldValues.put(hash, fieldValue);\n            } else {\n                fieldReader.readFieldValue(jsonReader, object);\n            }\n        }\n        if (fieldValues != null) {\n            for (Map.Entry<Long, Object> entry : fieldValues.entrySet()) {\n                FieldReader fieldReader = getFieldReader(entry.getKey());\n                fieldReader.accept(object, entry.getValue());\n            }\n        }\n        jsonReader.nextIfComma();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 35038707675.0,
        "Patch": "import com.alibaba.fastjson2.util.Fnv;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n@@ -139,6 +141,7 @@ final class ObjectReaderSeeAlso<T>\n            }\n        }\n        Map<Long, Object> fieldValues = null;\n        for (int i = 0; ; i++) {\n            if (jsonReader.nextIfObjectEnd()) {\n                if (object == null) {\n@@ -239,9 +242,6 @@ final class ObjectReaderSeeAlso<T>\n            if (object == null) {\n                object = createInstance(jsonReader.getContext().getFeatures() | features);\n                if (object == null) {\n                    throw new JSONException(\"create instance error, objectClass : \" + objectClass);\n                }\n            }\n            if (fieldReader == null) {\n@@ -249,7 +249,22 @@ final class ObjectReaderSeeAlso<T>\n                continue;\n            }\n            fieldReader.readFieldValue(jsonReader, object);\n            if (object == null) {\n                Object fieldValue = fieldReader.readFieldValue(jsonReader);\n                if (fieldValues == null) {\n                    fieldValues = new LinkedHashMap<>();\n                }\n                fieldValues.put(hash, fieldValue);\n            } else {\n                fieldReader.readFieldValue(jsonReader, object);\n            }\n        }\n        if (fieldValues != null) {\n            for (Map.Entry<Long, Object> entry : fieldValues.entrySet()) {\n                FieldReader fieldReader = getFieldReader(entry.getKey());\n                fieldReader.accept(object, entry.getValue());\n            }\n        }\n        jsonReader.nextIfComma();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 35412877847.0,
        "Patch": "16,8 +16,8 @@ import static com.alibaba.fastjson2.util.JDKUtils.*;\nclass JSONReaderASCII\n        extends JSONReaderUTF8 {\n    final String str;\n    static final int ESCAPE_INDEX_NOT_SET = -2;\n    protected int nextEscapeIndex = ESCAPE_INDEX_NOT_SET;\n    boolean checkEscapeFlag = true;\n    int nextEscapeIndex = -1;\n    JSONReaderASCII(Context ctx, String str, byte[] bytes, int offset, int length) {\n        super(ctx, str, bytes, offset, length);\n@@ -1441,9 +1441,19 @@ class JSONReaderASCII\n            if (index == -1) {\n                throw error(\"invalid escape character EOI\");\n            }\n            int slashIndex = index < nextEscapeIndex ? -1 : nextEscapeIndex;\n            if (slashIndex == ESCAPE_INDEX_NOT_SET || (slashIndex != -1 && slashIndex < offset)) {\n                nextEscapeIndex = slashIndex = IOUtils.indexOfChar(bytes, '\\\\', offset, end);\n            int slashIndex = -1;\n            if (checkEscapeFlag) {\n                if (index > nextEscapeIndex) {\n                    if (offset > nextEscapeIndex) {\n                        // scan the nearest '\\\\'\n                        nextEscapeIndex = IOUtils.indexOfChar(bytes, '\\\\', offset, end);  // use end\n                        if ((checkEscapeFlag = nextEscapeIndex > -1) && index > nextEscapeIndex) {\n                            slashIndex = nextEscapeIndex;\n                        }\n                    } else {\n                        slashIndex = nextEscapeIndex;\n                    }\n                }\n            }\n            if (slashIndex == -1) {\n                valueLength = index - offset;",
        "Label": "NPE_Fix"
    },
    {
        "ID": 35412878036.0,
        "Patch": "core/src/main/java/com/alibaba/fastjson2/JSONReaderASCII.java\n@@ -16,8 +16,8 @@ import static com.alibaba.fastjson2.util.JDKUtils.*;\nclass JSONReaderASCII\n        extends JSONReaderUTF8 {\n    final String str;\n    static final int ESCAPE_INDEX_NOT_SET = -2;\n    protected int nextEscapeIndex = ESCAPE_INDEX_NOT_SET;\n    boolean checkEscapeFlag = true;\n    int nextEscapeIndex = -1;\n    JSONReaderASCII(Context ctx, String str, byte[] bytes, int offset, int length) {\n        super(ctx, str, bytes, offset, length);\n@@ -1441,9 +1441,19 @@ class JSONReaderASCII\n            if (index == -1) {\n                throw error(\"invalid escape character EOI\");\n            }\n            int slashIndex = index < nextEscapeIndex ? -1 : nextEscapeIndex;\n            if (slashIndex == ESCAPE_INDEX_NOT_SET || (slashIndex != -1 && slashIndex < offset)) {\n                nextEscapeIndex = slashIndex = IOUtils.indexOfChar(bytes, '\\\\', offset, end);\n            int slashIndex = -1;\n            if (checkEscapeFlag) {\n                if (index > nextEscapeIndex) {\n                    if (offset > nextEscapeIndex) {\n                        // scan the nearest '\\\\'\n                        nextEscapeIndex = IOUtils.indexOfChar(bytes, '\\\\', offset, end);  // use end\n                        if ((checkEscapeFlag = nextEscapeIndex > -1) && index > nextEscapeIndex) {\n                            slashIndex = nextEscapeIndex;\n                        }\n                    } else {\n                        slashIndex = nextEscapeIndex;\n                    }\n                }\n            }\n            if (slashIndex == -1) {\n                valueLength = index - offset;",
        "Label": "NPE_Fix"
    },
    {
        "ID": 35412878219.0,
        "Patch": "import static com.alibaba.fastjson2.util.JDKUtils.*;\nclass JSONReaderASCII\n        extends JSONReaderUTF8 {\n    final String str;\n    static final int ESCAPE_INDEX_NOT_SET = -2;\n    protected int nextEscapeIndex = ESCAPE_INDEX_NOT_SET;\n    boolean checkEscapeFlag = true;\n    int nextEscapeIndex = -1;\n    JSONReaderASCII(Context ctx, String str, byte[] bytes, int offset, int length) {\n        super(ctx, str, bytes, offset, length);\n@@ -1441,9 +1441,19 @@ class JSONReaderASCII\n            if (index == -1) {\n                throw error(\"invalid escape character EOI\");\n            }\n            int slashIndex = index < nextEscapeIndex ? -1 : nextEscapeIndex;\n            if (slashIndex == ESCAPE_INDEX_NOT_SET || (slashIndex != -1 && slashIndex < offset)) {\n                nextEscapeIndex = slashIndex = IOUtils.indexOfChar(bytes, '\\\\', offset, end);\n            int slashIndex = -1;\n            if (checkEscapeFlag) {\n                if (index > nextEscapeIndex) {\n                    if (offset > nextEscapeIndex) {\n                        // scan the nearest '\\\\'\n                        nextEscapeIndex = IOUtils.indexOfChar(bytes, '\\\\', offset, end);  // use end\n                        if ((checkEscapeFlag = nextEscapeIndex > -1) && index > nextEscapeIndex) {\n                            slashIndex = nextEscapeIndex;\n                        }\n                    } else {\n                        slashIndex = nextEscapeIndex;\n                    }\n                }\n            }\n            if (slashIndex == -1) {\n                valueLength = index - offset;",
        "Label": "NPE_Fix"
    },
    {
        "ID": 35469138215.0,
        "Patch": "core/src/test/java/com/alibaba/fastjson2/JSONFactoryTest.java\n@@ -26,6 +26,8 @@ public class JSONFactoryTest {\n    @Test\n    public void test1() {\n        JSONFactory.setUseJacksonAnnotation(false);\n        JSONFactory.setUseGsonAnnotation(false);\n        assertFalse(JSONFactory.isUseGsonAnnotation());\n        assertFalse(JSONFactory.isUseJacksonAnnotation());\n        JSONFactory.setUseJacksonAnnotation(true);\n        JSONFactory.setUseGsonAnnotation(true);\n+1, -2•fastjson1-compatible/src/main/java/com/alibaba/fastjson/JSON.java\n@@ -2169,9 +2169,8 @@ public abstract class JSON\n                JSONFactory.getDefaultObjectReaderProvider(),\n                DEFAULT_PARSER_FEATURE\n        );\n        JSONReader reader = JSONReader.of(str, context);\n        try {\n        try (JSONReader reader = JSONReader.of(str, context)) {\n            if (reader.nextIfNullOrEmptyString()) {\n                return null;\n            }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 9745790591.0,
        "Patch": "core/src/main/java/com/alibaba/fastjson2/reader/ObjectReaderBean.java\n@@ -87,7 +87,7 @@ public abstract class ObjectReaderBean<T>\n                String fieldName1 = fieldName.substring(2);\n                long hashCode64LCase = Fnv.hashCode64LCase(fieldName1);\n                FieldReader fieldReader = getFieldReaderLCase(hashCode64LCase);\n                if (fieldReader != null) {\n                if (fieldReader != null && fieldReader.fieldClass == Boolean.class) {\n                    fieldReader.readFieldValue(jsonReader, object);\n                    return;\n                }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 9745790836.0,
        "Patch": "87,7 +87,7 @@ public abstract class ObjectReaderBean<T>\n                String fieldName1 = fieldName.substring(2);\n                long hashCode64LCase = Fnv.hashCode64LCase(fieldName1);\n                FieldReader fieldReader = getFieldReaderLCase(hashCode64LCase);\n                if (fieldReader != null) {\n                if (fieldReader != null && fieldReader.fieldClass == Boolean.class) {\n                    fieldReader.readFieldValue(jsonReader, object);\n                    return;\n                }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 9745791070.0,
        "Patch": "public abstract class ObjectReaderBean<T>\n                String fieldName1 = fieldName.substring(2);\n                long hashCode64LCase = Fnv.hashCode64LCase(fieldName1);\n                FieldReader fieldReader = getFieldReaderLCase(hashCode64LCase);\n                if (fieldReader != null) {\n                if (fieldReader != null && fieldReader.fieldClass == Boolean.class) {\n                    fieldReader.readFieldValue(jsonReader, object);\n                    return;\n                }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 10571587467.0,
        "Patch": "274,7 +274,10 @@ public class NacosDiscoveryProperties {\n\t\t\t\t}\n\t\t\t\telse if (ipType == null) {\n\t\t\t\t\tip = inetUtils.findFirstNonLoopbackHostInfo().getIpAddress();\n\t\t\t\t\tmetadata.put(IPV6, inetIPv6Utils.findIPv6Address());\n\t\t\t\t\tString iPv6Address = inetIPv6Utils.findIPv6Address();\n\t\t\t\t\tif (iPv6Address != null) {\n\t\t\t\t\t\tmetadata.put(IPV6, iPv6Address);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\n@@ -294,7 +297,7 @@ public class NacosDiscoveryProperties {\n\t\t\t\t\tInetAddress currentAddress = inetAddress.nextElement();\n\t\t\t\t\tif (currentAddress instanceof Inet4Address\n\t\t\t\t\t\t\t|| currentAddress instanceof Inet6Address\n\t\t\t\t\t\t\t\t\t&& !currentAddress.isLoopbackAddress()) {\n\t\t\t\t\t\t\t&& !currentAddress.isLoopbackAddress()) {\n\t\t\t\t\t\tip = currentAddress.getHostAddress();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n+2, -2•spring-cloud-alibaba-starters/spring-cloud-starter-alibaba-nacos-discovery/src/main/java/com/alibaba/cloud/nacos/util/InetIPv6Utils.java\n@@ -45,7 +45,7 @@ public class InetIPv6Utils {\n\tprivate InetUtils.HostInfo findFirstValidHostInfo() {\n\t\tInetAddress address = this.findFirstValidIPv6Address();\n\t\treturn this.getHostInfo(address);\n\t\treturn address != null ? this.getHostInfo(address) : null;\n\t}\n\tprivate InetAddress findFirstValidIPv6Address() {\n@@ -92,7 +92,7 @@ public class InetIPv6Utils {\n\tpublic String findIPv6Address() {\n\t\tInetUtils.HostInfo hostInfo = findFirstValidHostInfo();\n\t\treturn normalizeIPv6(hostInfo.getIpAddress());\n\t\treturn hostInfo != null ? normalizeIPv6(hostInfo.getIpAddress()) : null;\n\t}\n\tprivate String normalizeIPv6(String ip) {",
        "Label": "NPE_Fix"
    },
    {
        "ID": 224002128.0,
        "Patch": "public static String toString(final Object object, final ToStringStyle style, fi\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param excludeNulls\n     * @param excludeNullValues\n     *            whether to exclude fields whose values are null\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n@@ -351,12 +351,12 @@ public static String toString(final Object object, final ToStringStyle style, fi\n     *             if the Object is <code>null</code>\n     * \n     * @see ToStringExclude\n     * @since 2.1\n     * @since 3.6\n     */\n    public static <T> String toString(\n            final T object, final ToStringStyle style, final boolean outputTransients,\n            final boolean outputStatics, boolean excludeNulls, final Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics, excludeNulls)\n            final boolean outputStatics, boolean excludeNullValues, final Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics, excludeNullValues)\n                .toString();\n    }\n@@ -565,7 +565,7 @@ public ReflectionToStringBuilder(final Object object, final ToStringStyle style,\n     *            whether to include static fields\n     * @param excludeNullValues\n     *            whether to exclude fields who value is null\n     * @since 2.1\n     * @since 3.6\n     */\n    public <T> ReflectionToStringBuilder(\n            final T object, final ToStringStyle style, final StringBuffer buffer,\n@@ -641,7 +641,7 @@ protected void appendFieldsIn(final Class<?> clazz) {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    final Object fieldValue = this.getValue(field);\n                    if(!excludeNullValues || fieldValue != null){\n                    if (!excludeNullValues || fieldValue != null) {\n                        this.append(fieldName, fieldValue);\n                    }\n                } catch (final IllegalAccessException ex) {\n@@ -722,6 +722,7 @@ public boolean isAppendTransients() {\n     * </p>\n     *\n     * @return Whether or not to append fields whose values are null.\n     * @since 3.6\n     */\n    public boolean isExcludeNullValues() {\n        return this.excludeNullValues;\n@@ -773,6 +774,7 @@ public void setAppendTransients(final boolean appendTransients) {\n     *\n     * @param excludeNullValues\n     *            Whether or not to append fields whose values are null.\n     * @since 3.6\n     */\n    public void setExcludeNullValues(final boolean excludeNullValues) {\n        this.excludeNullValues = excludeNullValues;\n+7, -4•src/test/java/org/apache/commons/lang3/builder/ReflectionToStringBuilderExcludeNullValuesTest.java\n@@ -17,17 +17,20 @@\npackage org.apache.commons.lang3.builder;\nimport static org.junit.Assert.*;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport org.junit.Test;\npublic class ReflectionToStringBuilderExcludeNullValuesTest {\n    class TestFixture{\n    static class TestFixture {\n        @SuppressWarnings(\"unused\")\n        private Integer testIntegerField;\n        @SuppressWarnings(\"unused\")\n        private String testStringField;\n        public TestFixture(Integer a, String b){\n        public TestFixture(Integer a, String b) {\n            this.testIntegerField = a;\n            this.testStringField = b;\n        }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 224267191.0,
        "Patch": "904,7 +904,7 @@ private static int distance(final Class<?>[] classArray, final Class<?>[] toClas\n        Validate.isTrue(annotationCls != null, \"The annotation class must not be null\");\n        List<Class<?>> classes = (searchSupers ? getAllSuperclassesAndInterfaces(cls)\n                : new ArrayList<Class<?>>());\n        classes.add(cls);\n        classes.add(0, cls);\n        final List<Method> annotatedMethods = new ArrayList<>();\n        for (Class<?> acls : classes) {\n            final Method[] methods = (ignoreAccess ? acls.getDeclaredMethods() : acls.getMethods());",
        "Label": "NPE_Fix"
    },
    {
        "ID": 11761392364.0,
        "Patch": "public class FlinkSchemaUtil {\n      primaryKey = UniqueConstraint.primaryKey(UUID.randomUUID().toString(), columns);\n    }\n    validatePrimaryKey(schemaColumns, primaryKey);\n    if (primaryKey != null) {\n      validatePrimaryKey(schemaColumns, primaryKey);\n    }\n    return new ResolvedSchema(schemaColumns, Collections.emptyList(), primaryKey);\n  }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 290323369.0,
        "Patch": " import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.INDEX_DEFIN\nimport static org.apache.jackrabbit.oak.plugins.index.IndexConstants.REINDEX_ASYNC_PROPERTY_NAME;\nimport static org.apache.jackrabbit.oak.plugins.index.IndexConstants.REINDEX_COUNT;\nimport static org.apache.jackrabbit.oak.plugins.index.IndexConstants.REINDEX_PROPERTY_NAME;\nimport static org.apache.jackrabbit.oak.plugins.index.IndexConstants.TYPE_DISABLED;\nimport static org.apache.jackrabbit.oak.plugins.index.IndexConstants.TYPE_PROPERTY_NAME;\nimport static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.MISSING_NODE;\nimport static org.apache.jackrabbit.oak.spi.commit.CompositeEditor.compose;\n@@ -215,6 +216,12 @@ public class IndexUpdate implements Editor, PathSource {\n            return false;\n        }\n        //Do not attempt reindex of disabled indexes\n        PropertyState type = definition.getProperty(TYPE_PROPERTY_NAME);\n        if (type != null && TYPE_DISABLED.equals(type.getValue(Type.STRING))) {\n            return false;\n        }\n        PropertyState ps = definition.getProperty(REINDEX_PROPERTY_NAME);\n        if (ps != null && ps.getValue(BOOLEAN)) {\n            return !rootState.ignoreReindexFlags;\n+1, -1•oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/progress/IndexingProgressReporter.java\n@@ -194,7 +194,7 @@ public class IndexingProgressReporter implements NodeTraversalCallback {\n            if (!log.isDebugEnabled() && !st.reindex) {\n                continue;\n            }\n            if (st.updateCount > 0) {\n            if (st.updateCount > 0 || st.reindex) {\n                pw.printf(\"    - %s%n\", st);\n            }\n        }\n+40•oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdateTest.java\n@@ -27,6 +27,7 @@ import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.INDEX_DEFIN\nimport static org.apache.jackrabbit.oak.plugins.index.IndexConstants.REINDEX_ASYNC_PROPERTY_NAME;\nimport static org.apache.jackrabbit.oak.plugins.index.IndexConstants.REINDEX_COUNT;\nimport static org.apache.jackrabbit.oak.plugins.index.IndexConstants.REINDEX_PROPERTY_NAME;\nimport static org.apache.jackrabbit.oak.plugins.index.IndexConstants.TYPE_DISABLED;\nimport static org.apache.jackrabbit.oak.plugins.index.IndexConstants.TYPE_PROPERTY_NAME;\nimport static org.apache.jackrabbit.oak.plugins.index.IndexUtils.createIndexDefinition;\nimport static org.apache.jackrabbit.oak.InitialContent.INITIAL_CONTENT;\n@@ -47,14 +48,17 @@ import java.util.concurrent.atomic.AtomicInteger;\nimport javax.annotation.Nonnull;\nimport ch.qos.logback.classic.Level;\nimport com.google.common.collect.Maps;\nimport org.apache.jackrabbit.oak.api.CommitFailedException;\nimport org.apache.jackrabbit.oak.api.PropertyState;\nimport org.apache.jackrabbit.oak.api.Type;\nimport org.apache.jackrabbit.oak.commons.PathUtils;\nimport org.apache.jackrabbit.oak.commons.junit.LogCustomizer;\nimport org.apache.jackrabbit.oak.plugins.index.IndexUpdate.MissingIndexProviderStrategy;\nimport org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexEditorProvider;\nimport org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexLookup;\nimport org.apache.jackrabbit.oak.plugins.index.reference.ReferenceEditorProvider;\nimport org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState;\nimport org.apache.jackrabbit.oak.plugins.memory.MemoryNodeStore;\nimport org.apache.jackrabbit.oak.plugins.memory.PropertyValues;\n@@ -912,6 +916,42 @@ public class IndexUpdateTest {\n        assertFalse(indexed.getChildNode(\"oak:index\").getChildNode(\"newIndex\").getBoolean(IndexConstants.DISABLE_INDEXES_ON_NEXT_CYCLE));\n    }\n    @Test\n    public void reindexForDisabledIndexes() throws Exception{\n        EditorHook hook = new EditorHook(\n                new IndexUpdateProvider(new CompositeIndexEditorProvider(\n                        new PropertyIndexEditorProvider(),\n                        new ReferenceEditorProvider()\n                )));\n        NodeState before = builder.getNodeState();\n        createIndexDefinition(builder.child(INDEX_DEFINITIONS_NAME),\n                \"fooIndex\", true, false, ImmutableSet.of(\"foo\"), null);\n        builder.child(\"testRoot\").setProperty(\"foo\", \"abc\");\n        NodeState after = builder.getNodeState();\n        NodeState indexed = hook.processCommit(before, after, CommitInfo.EMPTY);\n        before = indexed;\n        builder = before.builder();\n        builder.getChildNode(\"oak:index\").getChildNode(\"fooIndex\").setProperty(TYPE_PROPERTY_NAME, TYPE_DISABLED);\n        builder.getChildNode(\"oak:index\").getChildNode(\"fooIndex\").setProperty(REINDEX_PROPERTY_NAME, true);\n        after = builder.getNodeState();\n        LogCustomizer customLogs = LogCustomizer.forLogger(IndexUpdate.class.getName()).filter(Level.INFO).create();\n        customLogs.starting();\n        before = after;\n        builder = before.builder();\n        builder.child(\"testRoot2\").setProperty(\"foo\", \"abc\");\n        after = builder.getNodeState();\n        indexed = hook.processCommit(before, after, CommitInfo.EMPTY);\n        assertTrue(customLogs.getLogs().isEmpty());\n        customLogs.finished();\n    }\n    private static void markCorrupt(NodeBuilder builder, String indexName) {\n        builder.getChildNode(INDEX_DEFINITIONS_NAME).getChildNode(indexName)\n                .setProperty(IndexConstants.CORRUPT_PROPERTY_NAME, ISO8601.format(Calendar.getInstance()));\n+1, -5•oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n@@ -1132,11 +1132,7 @@ public final class IndexDefinition implements Aggregate.AggregateMapper {\n            Map<String, PropertyDefinition> propDefns = newHashMap();\n            NodeState propNode = config.getChildNode(LuceneIndexConstants.PROP_NODE);\n            if (!propNode.exists()){\n                return Collections.emptyMap();\n            }\n            if (!hasOrderableChildren(propNode)){\n            if (propNode.exists() && !hasOrderableChildren(propNode)){\n                log.warn(\"Properties node for [{}] does not have orderable \" +\n                \"children in [{}]\", this, IndexDefinition.this);\n            }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 25644916873.0,
        "Patch": " public final class Lucene90HnswVectorsReader extends KnnVectorsReader {\n    @Override\n    public VectorScorer scorer(float[] target) {\n      if (size() == 0) {\n        return null;\n      }\n      OffHeapFloatVectorValues values = this.copy();\n      return new VectorScorer() {\n        @Override\n+3•lucene/backward-codecs/src/java/org/apache/lucene/backward_codecs/lucene91/Lucene91HnswVectorsReader.java\n@@ -494,6 +494,9 @@ public final class Lucene91HnswVectorsReader extends KnnVectorsReader {\n    @Override\n    public VectorScorer scorer(float[] target) {\n      if (size == 0) {\n        return null;\n      }\n      OffHeapFloatVectorValues values = this.copy();\n      return new VectorScorer() {\n        @Override\n+5•lucene/backward-codecs/src/test/org/apache/lucene/backward_codecs/lucene90/TestLucene90HnswVectorsFormat.java\n@@ -73,4 +73,9 @@ public class TestLucene90HnswVectorsFormat extends BaseKnnVectorsFormatTestCase\n  public void testByteVectorScorerIteration() {\n    // unimplemented\n  }\n  @Override\n  public void testEmptyByteVectorData() {\n    // unimplemented\n  }\n}\n+5•lucene/backward-codecs/src/test/org/apache/lucene/backward_codecs/lucene91/TestLucene91HnswVectorsFormat.java\n@@ -72,4 +72,9 @@ public class TestLucene91HnswVectorsFormat extends BaseKnnVectorsFormatTestCase\n  public void testByteVectorScorerIteration() {\n    // unimplemented\n  }\n  @Override\n  public void testEmptyByteVectorData() {\n    // unimplemented\n  }\n}\n+5•lucene/backward-codecs/src/test/org/apache/lucene/backward_codecs/lucene92/TestLucene92HnswVectorsFormat.java\n@@ -62,4 +62,9 @@ public class TestLucene92HnswVectorsFormat extends BaseKnnVectorsFormatTestCase\n  public void testByteVectorScorerIteration() {\n    // unimplemented\n  }\n  @Override\n  public void testEmptyByteVectorData() {\n    // unimplemented\n  }\n}",
        "Label": "NPE_Fix"
    },
    {
        "ID": 12749443626.0,
        "Patch": "private void commands(CliRequest cliRequest) {\n    // Maybe it's better to move some of those methods to separate class (SoC).\n    void properties(CliRequest cliRequest) throws Exception {\n        Properties paths = new Properties();\n        paths.put(\"session.topdir\", cliRequest.topdir.toString());\n        if (cliRequest.topdir != null) {\n            paths.put(\"session.topdir\", cliRequest.topdir.toString());\n        }\n        if (cliRequest.rootdir != null) {\n            paths.put(\"session.rootdir\", cliRequest.rootdir.toString());\n        }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 12749443830.0,
        "Patch": "maven-embedder/src/main/java/org/apache/maven/cli/MavenCli.java\n@@ -603,7 +603,9 @@ private void commands(CliRequest cliRequest) {\n    // Maybe it's better to move some of those methods to separate class (SoC).\n    void properties(CliRequest cliRequest) throws Exception {\n        Properties paths = new Properties();\n        paths.put(\"session.topdir\", cliRequest.topdir.toString());\n        if (cliRequest.topdir != null) {\n            paths.put(\"session.topdir\", cliRequest.topdir.toString());\n        }\n        if (cliRequest.rootdir != null) {\n            paths.put(\"session.rootdir\", cliRequest.rootdir.toString());\n        }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 24423934371.0,
        "Patch": "import org.apache.maven.api.services.ModelBuilderException;\nimport org.apache.maven.api.services.ModelBuilderRequest;\nimport org.apache.maven.api.services.ModelBuilderResult;\nimport org.apache.maven.api.services.ModelCache;\nimport org.apache.maven.api.services.ModelProblemCollector;\nimport org.apache.maven.api.services.ModelResolver;\nimport org.apache.maven.api.services.ModelSource;\n@@ -204,11 +203,12 @@ private ModelBuilderResult buildModel(RepositorySystemSession session, MavenProj\n        request.transformerContextBuilder(modelBuilder.newTransformerContextBuilder());\n        request.systemProperties(session.getSystemProperties());\n        request.userProperties(session.getUserProperties());\n        ModelCache modelCache = DefaultModelCache.newInstance(session, false);\n        Map map = (Map) session.getCache().get(session, DefaultModelCache.class.getName());\n        System.out.println(\"ModelCache contains \" + map.size());\n        map.keySet().forEach(k -> System.out.println(\"    \" + k));\n        request.modelCache(modelCache);\n        request.modelCache(DefaultModelCache.newInstance(session, false));\n        if (session.getCache() != null) {\n            Map map = (Map) session.getCache().get(session, DefaultModelCache.class.getName());\n            System.out.println(\"ModelCache contains \" + map.size());\n            map.keySet().forEach(k -> System.out.println(\"    \" + k));\n        }\n        return modelBuilder.build(request.build());\n    }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 30014610441.0,
        "Patch": " private Model doReadFileModel(\n                String version = parent.getVersion();\n                String path = Optional.ofNullable(parent.getRelativePath()).orElse(\"..\");\n                if (version == null && !path.isEmpty()) {\n                    Path pomFile = model.getPomFile();\n                    Path relativePath = Paths.get(path);\n                    Path pomPath = pomFile.resolveSibling(relativePath).normalize();\n                    if (Files.isDirectory(pomPath)) {\n                        pomPath = getModelProcessor().locateExistingPom(pomPath);\n                    }\n                    if (pomPath != null && Files.isRegularFile(pomPath)) {\n                        ModelBuilderRequest parentRequest =\n                                ModelBuilderRequest.build(request, ModelSource.fromPath(pomPath));\n                        Model parentModel = readFileModel(parentRequest, problems);\n                        if (parentModel != null) {\n                            if ((groupId == null || groupId.equals(parentModel.getGroupId()))\n                                    && (artifactId == null || artifactId.equals(parentModel.getArtifactId()))) {\n                                groupId = getGroupId(parentModel);\n                                artifactId = parentModel.getArtifactId();\n                                version = getVersion(parentModel);\n                            String parentGroupId = getGroupId(parentModel);\n                            String parentArtifactId = parentModel.getArtifactId();\n                            String parentVersion = getVersion(parentModel);\n                            if ((groupId == null || groupId.equals(parentGroupId))\n                                    && (artifactId == null || artifactId.equals(parentArtifactId))) {\n                                model = model.withParent(parent.with()\n                                        .groupId(groupId)\n                                        .artifactId(artifactId)\n                                        .version(version)\n                                        .groupId(parentGroupId)\n                                        .artifactId(parentArtifactId)\n                                        .version(parentVersion)\n                                        .build());\n                            }\n                        }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 30385061433.0,
        "Patch": "maven-core/src/main/java/org/apache/maven/project/DefaultProjectBuilder.java\n@@ -692,7 +692,9 @@ private InterimResult build(\n            // In case the model is using CI friendly versions, at this point, it will contain uninterpolated version\n            // such as ${revision}${changelist}, so we need to take care of it now\n            Model modelWithVersion = getModelWithInterpolatedVersion(model, result.getProblems()::add);\n            modelPool.put(model.getPomFile(), modelWithVersion);\n            if (model.getPomFile() != null) {\n                modelPool.put(model.getPomFile(), modelWithVersion);\n            }\n            InterimResult interimResult = new InterimResult(pomFile, modelBuildingRequest, result, project, isRoot);",
        "Label": "NPE_Fix"
    },
    {
        "ID": 30767613303.0,
        "Patch": " Model readParent(Model childModel) throws ModelBuilderException {\n                                    + \", must be \\\"pom\\\" but is \\\"\" + parentModel.getPackaging() + \"\\\"\",\n                            parentModel.getLocation(\"packaging\"));\n                }\n                result.setParentModel(parentModel);\n            } else {\n                String superModelVersion = childModel.getModelVersion();\n                if (!VALID_MODEL_VERSIONS.contains(superModelVersion)) {\n@@ -1168,7 +1169,6 @@ private Model readEffectiveModel() throws ModelBuilderException {\n            }\n            Model parentModel = readParent(inputModel);\n            result.setParentModel(parentModel);\n            List<Profile> parentInterpolatedProfiles =\n                    interpolateActivations(parentModel.getProfiles(), profileActivationContext, this);",
        "Label": "NPE_Fix"
    },
    {
        "ID": 19671447070.0,
        "Patch": "public class SCBEngine {\n  }\n  public Environment getEnvironment() {\n    if (this.applicationContext == null) {\n      // some test cases\n      return null;\n    }\n    return this.applicationContext.getEnvironment();\n  }\n+4•core/src/main/java/org/apache/servicecomb/core/bootup/ConfigurationProblemsCollector.java\n@@ -33,6 +33,10 @@ import org.springframework.core.env.Environment;\npublic class ConfigurationProblemsCollector implements BootUpInformationCollector {\n  @Override\n  public String collect(SCBEngine engine) {\n    if (engine.getEnvironment() == null) {\n      // some test cases\n      return null;\n    }\n    StringBuilder result = new StringBuilder();\n    collectCsePrefix(engine.getEnvironment(), result);\n    collectServiceDefinition(engine.getEnvironment(), result);",
        "Label": "NPE_Fix"
    },
    {
        "ID": 9220678028.0,
        "Patch": "foundations/foundation-ssl/src/main/java/org/apache/servicecomb/foundation/ssl/SSLManager.java\n@@ -34,6 +34,8 @@ import javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\nimport org.apache.commons.lang.StringUtils;\n/**\n * 根据传递的SSLOption构造SSL上下文。请参考JSSE获取相关API的层次参考。\n *\n@@ -216,7 +218,11 @@ public final class SSLManager {\n  public static String[] getEnabledCiphers(SSLOption sslOption) {\n    SSLOption option = new SSLOption();\n    option.setProtocols(sslOption.getProtocols());\n    if (StringUtils.isNotEmpty(sslOption.getProtocols())) {\n      option.setProtocols(sslOption.getProtocols());\n    } else {\n      option.setProtocols(\"TLSv1.2\");\n    }\n    option.setCiphers(sslOption.getCiphers());\n    SSLCustom custom = SSLCustom.defaultSSLCustom();\n    SSLSocket socket = createSSLSocket(option, custom);",
        "Label": "NPE_Fix"
    },
    {
        "ID": 10274807843.0,
        "Patch": " public final class MySQLClient {\n        try {\n            running = false;\n            channel.close().sync();\n            eventLoopGroup.shutdownGracefully();\n            if (null != eventLoopGroup) {\n                eventLoopGroup.shutdownGracefully();\n            }\n        } catch (final InterruptedException ex) {\n            log.error(\"close channel interrupted\", ex);\n        }",
        "Label": "NPE_Fix"
    },
    {
        "ID": 10305290708.0,
        "Patch": "public final class GovernanceRepositoryAPIImpl implements GovernanceRepositoryAP\n    @Override\n    public Optional<String> getJobItemProgress(final String jobId, final int shardingItem) {\n        return Optional.ofNullable(repository.getDirectly(PipelineMetaDataNode.getJobOffsetItemPath(jobId, shardingItem)));\n        String text = repository.getDirectly(PipelineMetaDataNode.getJobOffsetItemPath(jobId, shardingItem));\n        return Strings.isNullOrEmpty(text) ? Optional.empty() : Optional.of(text);\n    }\n    @Override",
        "Label": "NPE_Fix"
    },
    {
        "ID": 13831878900.0,
        "Patch": "public final class MySQLDataSourceChecker extends AbstractDataSourceChecker {\n                preparedStatement.setString(parameterIndex++, entry.getKey());\n            }\n            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n                resultSet.next();\n                String key = resultSet.getString(1).toUpperCase();\n                String toBeCheckedValue = REQUIRED_VARIABLES.get(key);\n                String actualValue = resultSet.getString(2);\n                ShardingSpherePreconditions.checkState(toBeCheckedValue.equalsIgnoreCase(actualValue),\n                        () -> new PrepareJobWithInvalidSourceDataSourceException(key, toBeCheckedValue, actualValue));\n                while (resultSet.next()) {\n                    String key = resultSet.getString(1).toUpperCase();\n                    String expectedValue = REQUIRED_VARIABLES.get(key);\n                    String actualValue = resultSet.getString(2);\n                    ShardingSpherePreconditions.checkState(expectedValue.equalsIgnoreCase(actualValue),\n                            () -> new PrepareJobWithInvalidSourceDataSourceException(key, expectedValue, actualValue));\n                }\n            }\n        } catch (final SQLException ex) {\n            throw new PrepareJobWithCheckPrivilegeFailedException(ex);\n+6, -5•kernel/data-pipeline/dialect/mysql/src/test/java/org/apache/shardingsphere/data/pipeline/mysql/check/datasource/MySQLDataSourceCheckerTest.java\n@@ -33,6 +33,7 @@ import java.sql.SQLException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n@@ -89,18 +90,18 @@ class MySQLDataSourceCheckerTest {\n    @Test\n    void assertCheckVariableSuccess() throws SQLException {\n        when(resultSet.next()).thenReturn(true, true);\n        when(resultSet.next()).thenReturn(true, true, true, false);\n        when(resultSet.getString(1)).thenReturn(\"LOG_BIN\", \"BINLOG_FORMAT\", \"BINLOG_ROW_IMAGE\");\n        when(resultSet.getString(2)).thenReturn(\"ON\", \"ROW\", \"FULL\");\n        new MySQLDataSourceChecker().checkVariable(dataSources);\n        assertDoesNotThrow(() -> new MySQLDataSourceChecker().checkVariable(dataSources));\n        verify(preparedStatement, times(1)).executeQuery();\n    }\n    @Test\n    void assertCheckVariableWithWrongVariable() throws SQLException {\n        when(resultSet.next()).thenReturn(true, true);\n        when(resultSet.getString(1)).thenReturn(\"LOG_BIN\", \"BINLOG_FORMAT\");\n        when(resultSet.getString(2)).thenReturn(\"OFF\", \"ROW\");\n        when(resultSet.next()).thenReturn(true, true, false);\n        when(resultSet.getString(1)).thenReturn(\"BINLOG_FORMAT\", \"LOG_BIN\");\n        when(resultSet.getString(2)).thenReturn(\"ROW\", \"OFF\");\n        assertThrows(PrepareJobWithInvalidSourceDataSourceException.class, () -> new MySQLDataSourceChecker().checkVariable(dataSources));\n    }\n+1, -3•mode/type/cluster/core/src/main/java/org/apache/shardingsphere/mode/manager/cluster/NewClusterModeContextManager.java\n@@ -109,9 +109,7 @@ public final class NewClusterModeContextManager implements ModeContextManager, C\n    @Override\n    public void alterRuleConfiguration(final String databaseName, final Collection<RuleConfiguration> ruleConfigs) {\n        contextManager.getMetaDataContexts().getPersistService().getDatabaseRulePersistService().persist(databaseName,\n                contextManager.getMetaDataContexts().getMetaData().getDatabase(databaseName).getResourceMetaData().getDataSources(),\n                contextManager.getMetaDataContexts().getMetaData().getDatabase(databaseName).getRuleMetaData().getRules(), ruleConfigs);\n        contextManager.getMetaDataContexts().getPersistService().getDatabaseRulePersistService().persist(databaseName, ruleConfigs);\n    }\n    @Override",
        "Label": "NPE_Fix"
    },
    {
        "ID": 14283057293.0,
        "Patch": "55,7 +55,7 @@\n        </dependency>\n        <dependency>\n            <groupId>org.apache.shardingsphere</groupId>\n            <artifactId>shardingsphere-single-core</artifactId>\n            <artifactId>shardingsphere-single-api</artifactId>\n            <version>${project.version}</version>\n        </dependency>\n        <dependency>\n+1, -1•infra/context/src/main/java/org/apache/shardingsphere/infra/connection/refresher/type/table/CreateTableStatementSchemaRefresher.java\n@@ -61,7 +61,7 @@ public final class CreateTableStatementSchemaRefresher implements MetaDataRefres\n            AlterSchemaMetaDataPOJO alterSchemaMetaDataPOJO = new AlterSchemaMetaDataPOJO(database.getName(), schemaName, logicDataSourceNames);\n            alterSchemaMetaDataPOJO.getAlteredTables().add(actualTableMetaData.get());\n            modeContextManager.alterSchemaMetaData(alterSchemaMetaDataPOJO);\n            if (isSingleTable && TableRefreshUtils.isRuleRefreshRequired(database.getName(), database.getProtocolType(), ruleMetaData, schemaName, tableName)) {\n            if (isSingleTable && TableRefreshUtils.isRuleRefreshRequired(ruleMetaData, schemaName, tableName)) {\n                modeContextManager.alterRuleConfiguration(database.getName(), ruleMetaData.getConfigurations());\n            }\n        }\n+1, -1•infra/context/src/main/java/org/apache/shardingsphere/infra/connection/refresher/type/table/DropTableStatementSchemaRefresher.java\n@@ -45,7 +45,7 @@ public final class DropTableStatementSchemaRefresher implements MetaDataRefreshe\n        for (SimpleTableSegment each : sqlStatement.getTables()) {\n            String tableName = each.getTableName().getIdentifier().getValue();\n            if (isSingleTable(tableName, ruleMetaData)\n                    && TableRefreshUtils.isRuleRefreshRequired(database.getName(), database.getProtocolType(), ruleMetaData, schemaName, tableName)) {\n                    && TableRefreshUtils.isRuleRefreshRequired(ruleMetaData, schemaName, tableName)) {\n                modeContextManager.alterRuleConfiguration(database.getName(), ruleMetaData.getConfigurations());\n                break;\n            }\n+23, -20•infra/context/src/main/java/org/apache/shardingsphere/infra/connection/refresher/util/TableRefreshUtils.java\n@@ -17,14 +17,15 @@\npackage org.apache.shardingsphere.infra.connection.refresher.util;\nimport com.google.common.base.Joiner;\nimport lombok.AccessLevel;\nimport lombok.NoArgsConstructor;\nimport org.apache.shardingsphere.infra.database.type.DatabaseType;\nimport org.apache.shardingsphere.infra.config.rule.RuleConfiguration;\nimport org.apache.shardingsphere.infra.datanode.DataNode;\nimport org.apache.shardingsphere.infra.metadata.database.rule.ShardingSphereRuleMetaData;\nimport org.apache.shardingsphere.single.constant.SingleTableConstants;\nimport org.apache.shardingsphere.single.rule.SingleRule;\nimport org.apache.shardingsphere.single.util.SingleTableLoadUtils;\nimport org.apache.shardingsphere.infra.rule.identifier.type.MutableDataNodeRule;\nimport org.apache.shardingsphere.single.api.config.SingleRuleConfiguration;\nimport org.apache.shardingsphere.single.api.constant.SingleTableConstants;\nimport java.util.Collection;\nimport java.util.Optional;\n@@ -38,35 +39,37 @@ public final class TableRefreshUtils {\n    /**\n     * Get aggregated data source map.\n     * \n     * @param databaseName database name\n     * @param databaseType database type\n     * @param ruleMetaData rule meta data\n     * @param schemaName schema name\n     * @param tableName table name\n     * @return aggregated data source map\n     */\n    public static boolean isRuleRefreshRequired(final String databaseName, final DatabaseType databaseType, final ShardingSphereRuleMetaData ruleMetaData,\n                                                final String schemaName, final String tableName) {\n        Optional<SingleRule> singleRule = ruleMetaData.findSingleRule(SingleRule.class);\n    public static boolean isRuleRefreshRequired(final ShardingSphereRuleMetaData ruleMetaData, final String schemaName, final String tableName) {\n        Optional<MutableDataNodeRule> singleRule = ruleMetaData.findSingleRule(MutableDataNodeRule.class);\n        if (!singleRule.isPresent()) {\n            return false;\n        }\n        Optional<DataNode> dataNode = singleRule.get().findTableDataNode(schemaName, tableName);\n        if (!dataNode.isPresent()) {\n        RuleConfiguration ruleConfiguration = singleRule.get().getConfiguration();\n        if (!(ruleConfiguration instanceof SingleRuleConfiguration)) {\n            return false;\n        }\n        DataNode actualNode = dataNode.get();\n        Collection<String> tablesConfig = SingleTableLoadUtils.splitTableLines(singleRule.get().getConfiguration().getTables());\n        Collection<String> tablesConfig = ((SingleRuleConfiguration) ruleConfiguration).getTables();\n        if (tablesConfig.contains(SingleTableConstants.ALL_TABLES) || tablesConfig.contains(SingleTableConstants.ALL_SCHEMA_TABLES)) {\n            return false;\n        }\n        Collection<DataNode> dataNods = SingleTableLoadUtils.convertToDataNodes(databaseName, databaseType, tablesConfig);\n        for (DataNode each : dataNods) {\n            if (each.equals(actualNode) || SingleTableConstants.ASTERISK.equals(each.getSchemaName())\n                    || each.getDataSourceName().equals(actualNode.getDataSourceName()) && SingleTableConstants.ASTERISK.equals(each.getTableName())) {\n                return false;\n            }\n        Optional<DataNode> dataNode = singleRule.get().findTableDataNode(schemaName, tableName);\n        if (!dataNode.isPresent()) {\n            return false;\n        }\n        return true;\n        DataNode actualNode = dataNode.get();\n        return !tablesConfig.contains(joinDataNodeSegments(actualNode.getDataSourceName(), actualNode.getSchemaName(), actualNode.getTableName()))\n                && !tablesConfig.contains(joinDataNodeSegments(actualNode.getDataSourceName(), SingleTableConstants.ASTERISK))\n                && !tablesConfig.contains(joinDataNodeSegments(actualNode.getDataSourceName(), actualNode.getTableName()))\n                && !tablesConfig.contains(joinDataNodeSegments(actualNode.getDataSourceName(), SingleTableConstants.ASTERISK, SingleTableConstants.ASTERISK))\n                && !tablesConfig.contains(joinDataNodeSegments(actualNode.getDataSourceName(), actualNode.getSchemaName(), SingleTableConstants.ASTERISK));\n    }\n    private static String joinDataNodeSegments(final String... segments) {\n        return Joiner.on(\".\").join(segments);\n    }\n}\n+1, -1•kernel/single/core/src/main/java/org/apache/shardingsphere/single/constant/SingleTableConstants.java → kernel/single/api/src/main/java/org/apache/shardingsphere/single/api/constant/SingleTableConstants.java\n@@ -15,7 +15,7 @@\n * limitations under the License.\n */\npackage org.apache.shardingsphere.single.constant;\npackage org.apache.shardingsphere.single.api.constant;\nimport lombok.AccessLevel;\nimport lombok.NoArgsConstructor;\n+1, -1•kernel/single/core/src/main/java/org/apache/shardingsphere/single/datanode/SingleTableDataNodeLoader.java\n@@ -23,7 +23,7 @@ import org.apache.shardingsphere.infra.database.type.DatabaseType;\nimport org.apache.shardingsphere.infra.datanode.DataNode;\nimport org.apache.shardingsphere.infra.metadata.database.schema.loader.common.SchemaMetaDataLoader;\nimport org.apache.shardingsphere.infra.rule.ShardingSphereRule;\nimport org.apache.shardingsphere.single.constant.SingleTableConstants;\nimport org.apache.shardingsphere.single.api.constant.SingleTableConstants;\nimport org.apache.shardingsphere.single.exception.SingleTablesLoadingException;\nimport org.apache.shardingsphere.single.util.SingleTableLoadUtils;\n+1, -1•kernel/single/core/src/main/java/org/apache/shardingsphere/single/util/SingleTableLoadUtils.java\n@@ -26,7 +26,7 @@ import org.apache.shardingsphere.infra.datanode.DataNode;\nimport org.apache.shardingsphere.infra.rule.ShardingSphereRule;\nimport org.apache.shardingsphere.infra.rule.identifier.type.DataSourceContainedRule;\nimport org.apache.shardingsphere.infra.rule.identifier.type.TableContainedRule;\nimport org.apache.shardingsphere.single.constant.SingleTableConstants;\nimport org.apache.shardingsphere.single.api.constant.SingleTableConstants;\nimport javax.sql.DataSource;\nimport java.util.Collection;\n+1, -1•kernel/single/distsql/handler/src/main/java/org/apache/shardingsphere/single/distsql/handler/update/LoadSingleTableStatementUpdater.java\n@@ -29,7 +29,7 @@ import org.apache.shardingsphere.infra.metadata.database.schema.model.ShardingSp\nimport org.apache.shardingsphere.infra.rule.identifier.type.DataSourceContainedRule;\nimport org.apache.shardingsphere.infra.util.exception.ShardingSpherePreconditions;\nimport org.apache.shardingsphere.single.api.config.SingleRuleConfiguration;\nimport org.apache.shardingsphere.single.constant.SingleTableConstants;\nimport org.apache.shardingsphere.single.api.constant.SingleTableConstants;\nimport org.apache.shardingsphere.single.datanode.SingleTableDataNodeLoader;\nimport org.apache.shardingsphere.single.distsql.handler.exception.MissingRequiredSingleTableException;\nimport org.apache.shardingsphere.single.distsql.segment.SingleTableSegment;\n+1, -1•kernel/single/distsql/handler/src/main/java/org/apache/shardingsphere/single/distsql/handler/update/UnloadSingleTableStatementUpdater.java\n@@ -28,7 +28,7 @@ import org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabase;\nimport org.apache.shardingsphere.infra.metadata.database.schema.model.ShardingSphereTable;\nimport org.apache.shardingsphere.infra.util.exception.ShardingSpherePreconditions;\nimport org.apache.shardingsphere.single.api.config.SingleRuleConfiguration;\nimport org.apache.shardingsphere.single.constant.SingleTableConstants;\nimport org.apache.shardingsphere.single.api.constant.SingleTableConstants;\nimport org.apache.shardingsphere.single.distsql.statement.rdl.UnloadSingleTableStatement;\nimport org.apache.shardingsphere.single.exception.SingleTableNotFoundException;\nimport org.apache.shardingsphere.single.rule.SingleRule;",
        "Label": "NPE_Fix"
    },
    {
        "ID": 14344177378.0,
        "Patch": "public final class BroadcastRuleConfigurationEventBuilder implements RuleConfigu\n    }\n    private BroadcastRuleConfiguration swapBroadcastTableRuleConfig(final String yamlContext) {\n        BroadcastRuleConfiguration result = new BroadcastRuleConfiguration();\n        YamlBroadcastRuleConfiguration yamlBroadcastRuleConfiguration = YamlEngine.unmarshal(yamlContext, YamlBroadcastRuleConfiguration.class);\n        result.setTables(yamlBroadcastRuleConfiguration.getTables());\n        return result;\n        return new BroadcastRuleConfiguration(yamlBroadcastRuleConfiguration.getTables());\n    }\n}\n+6, -5•features/broadcast/core/src/main/java/org/apache/shardingsphere/broadcast/subscriber/BroadcastConfigurationSubscriber.java\n@@ -63,10 +63,10 @@ public final class BroadcastConfigurationSubscriber implements RuleConfiguration\n        BroadcastRuleConfiguration config;\n        if (rule.isPresent()) {\n            config = rule.get().getConfiguration();\n            config.setTables(needToAddedConfig.getTables());\n            config.getTables().clear();\n            config.getTables().addAll(needToAddedConfig.getTables());\n        } else {\n            config = new BroadcastRuleConfiguration();\n            config.setTables(needToAddedConfig.getTables());\n            config = new BroadcastRuleConfiguration(needToAddedConfig.getTables());\n        }\n        instanceContext.getEventBusContext().post(new DatabaseRuleConfigurationChangedEvent(event.getDatabaseName(), config));\n    }\n@@ -81,7 +81,8 @@ public final class BroadcastConfigurationSubscriber implements RuleConfiguration\n        ShardingSphereDatabase database = databases.get(event.getDatabaseName());\n        BroadcastRuleConfiguration needToAlteredConfig = event.getConfig();\n        BroadcastRuleConfiguration config = database.getRuleMetaData().getSingleRule(BroadcastRule.class).getConfiguration();\n        config.setTables(needToAlteredConfig.getTables());\n        config.getTables().clear();\n        config.getTables().addAll(needToAlteredConfig.getTables());\n        instanceContext.getEventBusContext().post(new DatabaseRuleConfigurationChangedEvent(event.getDatabaseName(), config));\n    }\n@@ -94,7 +95,7 @@ public final class BroadcastConfigurationSubscriber implements RuleConfiguration\n    public synchronized void renew(final DeleteBroadcastConfigurationEvent event) {\n        ShardingSphereDatabase database = databases.get(event.getDatabaseName());\n        BroadcastRuleConfiguration config = database.getRuleMetaData().getSingleRule(BroadcastRule.class).getConfiguration();\n        config.setTables(null);\n        config.getTables().clear();\n        instanceContext.getEventBusContext().post(new DatabaseRuleConfigurationChangedEvent(event.getDatabaseName(), config));\n    }\n}\n+2, -3•features/broadcast/core/src/main/java/org/apache/shardingsphere/broadcast/yaml/swapper/NewYamlBroadcastRuleConfigurationSwapper.java\n@@ -46,12 +46,11 @@ public final class NewYamlBroadcastRuleConfigurationSwapper implements NewYamlRu\n    @Override\n    public BroadcastRuleConfiguration swapToObject(final Collection<YamlDataNode> dataNodes) {\n        BroadcastRuleConfiguration result = new BroadcastRuleConfiguration();\n        if (!dataNodes.isEmpty()) {\n            YamlBroadcastRuleConfiguration yamlBroadcastRuleConfiguration = YamlEngine.unmarshal(dataNodes.iterator().next().getValue(), YamlBroadcastRuleConfiguration.class);\n            result.setTables(yamlBroadcastRuleConfiguration.getTables());\n            return new BroadcastRuleConfiguration(yamlBroadcastRuleConfiguration.getTables());\n        }\n        return result;\n        return new BroadcastRuleConfiguration(Collections.emptyList());\n    }\n    @Override",
        "Label": "NPE_Fix"
    },
    {
        "ID": 14344190262.0,
        "Patch": "public final class MaskConfigurationSubscriber implements RuleConfigurationSubsc\n     * @param event add mask configuration event\n     */\n    @Subscribe\n    public synchronized void renew(final AddMaskConfigurationEvent<MaskTableRuleConfiguration> event) {\n    public synchronized void renew(final AddMaskConfigurationEvent event) {\n        ShardingSphereDatabase database = databases.get(event.getDatabaseName());\n        MaskTableRuleConfiguration needToAddedConfig = event.getConfig();\n        Optional<MaskRule> rule = database.getRuleMetaData().findSingleRule(MaskRule.class);\n@@ -79,7 +79,7 @@ public final class MaskConfigurationSubscriber implements RuleConfigurationSubsc\n     * @param event alter mask configuration event\n     */\n    @Subscribe\n    public synchronized void renew(final AlterMaskConfigurationEvent<MaskTableRuleConfiguration> event) {\n    public synchronized void renew(final AlterMaskConfigurationEvent event) {\n        ShardingSphereDatabase database = databases.get(event.getDatabaseName());\n        MaskTableRuleConfiguration needToAlteredConfig = event.getConfig();\n        MaskRuleConfiguration config = (MaskRuleConfiguration) database.getRuleMetaData().getSingleRule(MaskRule.class).getConfiguration();\n+1, -1•features/readwrite-splitting/core/src/test/java/org/apache/shardingsphere/readwritesplitting/metadata/converter/ReadwriteSplittingNodeConverterTest.java\n@@ -71,7 +71,7 @@ class ReadwriteSplittingNodeConverterTest {\n    @Test\n    void assertGetLoadBalancerName() {\n        Optional<String> actual = ReadwriteSplittingNodeConverter.getLoadBalancerName(\"/metadata/foo_db/rules/readwrite_splitting/load_balancers/random\");\n        Optional<String> actual = ReadwriteSplittingNodeConverter.getLoadBalancerName(\"/metadata/foo_db/rules/readwrite_splitting/load_balancers/random/versions/1\");\n        assertTrue(actual.isPresent());\n        assertThat(actual.get(), is(\"random\"));\n    }\n+3•features/readwrite-splitting/core/src/test/java/org/apache/shardingsphere/readwritesplitting/yaml/swapper/NewYamlReadwriteSplittingRuleConfigurationSwapperTest.java\n@@ -22,6 +22,7 @@ import org.apache.shardingsphere.infra.util.yaml.datanode.YamlDataNode;\nimport org.apache.shardingsphere.readwritesplitting.api.ReadwriteSplittingRuleConfiguration;\nimport org.apache.shardingsphere.readwritesplitting.api.rule.ReadwriteSplittingDataSourceRuleConfiguration;\nimport org.apache.shardingsphere.readwritesplitting.api.transaction.TransactionalReadQueryStrategy;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\nimport java.util.Arrays;\n@@ -66,6 +67,8 @@ class NewYamlReadwriteSplittingRuleConfigurationSwapperTest {\n        assertThat(result.getLoadBalancers().size(), is(0));\n    }\n    // Fixme\n    @Disabled\n    @Test\n    void assertSwapToObject() {\n        Collection<YamlDataNode> config = new LinkedList<>();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 35038707310.0,
        "Patch": "6 +7,8 @@ import com.alibaba.fastjson2.util.Fnv;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n@@ -139,6 +141,7 @@ final class ObjectReaderSeeAlso<T>\n            }\n        }\n        Map<Long, Object> fieldValues = null;\n        for (int i = 0; ; i++) {\n            if (jsonReader.nextIfObjectEnd()) {\n                if (object == null) {\n@@ -239,9 +242,6 @@ final class ObjectReaderSeeAlso<T>\n            if (object == null) {\n                object = createInstance(jsonReader.getContext().getFeatures() | features);\n                if (object == null) {\n                    throw new JSONException(\"create instance error, objectClass : \" + objectClass);\n                }\n            }\n            if (fieldReader == null) {\n@@ -249,7 +249,22 @@ final class ObjectReaderSeeAlso<T>\n                continue;\n            }\n            fieldReader.readFieldValue(jsonReader, object);\n            if (object == null) {\n                Object fieldValue = fieldReader.readFieldValue(jsonReader);\n                if (fieldValues == null) {\n                    fieldValues = new LinkedHashMap<>();\n                }\n                fieldValues.put(hash, fieldValue);\n            } else {\n                fieldReader.readFieldValue(jsonReader, object);\n            }\n        }\n        if (fieldValues != null) {\n            for (Map.Entry<Long, Object> entry : fieldValues.entrySet()) {\n                FieldReader fieldReader = getFieldReader(entry.getKey());\n                fieldReader.accept(object, entry.getValue());\n            }\n        }\n        jsonReader.nextIfComma();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 35038707417.0,
        "Patch": "core/src/main/java/com/alibaba/fastjson2/reader/ObjectReaderSeeAlso.java\n@@ -7,6 +7,8 @@ import com.alibaba.fastjson2.util.Fnv;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n@@ -139,6 +141,7 @@ final class ObjectReaderSeeAlso<T>\n            }\n        }\n        Map<Long, Object> fieldValues = null;\n        for (int i = 0; ; i++) {\n            if (jsonReader.nextIfObjectEnd()) {\n                if (object == null) {\n@@ -239,9 +242,6 @@ final class ObjectReaderSeeAlso<T>\n            if (object == null) {\n                object = createInstance(jsonReader.getContext().getFeatures() | features);\n                if (object == null) {\n                    throw new JSONException(\"create instance error, objectClass : \" + objectClass);\n                }\n            }\n            if (fieldReader == null) {\n@@ -249,7 +249,22 @@ final class ObjectReaderSeeAlso<T>\n                continue;\n            }\n            fieldReader.readFieldValue(jsonReader, object);\n            if (object == null) {\n                Object fieldValue = fieldReader.readFieldValue(jsonReader);\n                if (fieldValues == null) {\n                    fieldValues = new LinkedHashMap<>();\n                }\n                fieldValues.put(hash, fieldValue);\n            } else {\n                fieldReader.readFieldValue(jsonReader, object);\n            }\n        }\n        if (fieldValues != null) {\n            for (Map.Entry<Long, Object> entry : fieldValues.entrySet()) {\n                FieldReader fieldReader = getFieldReader(entry.getKey());\n                fieldReader.accept(object, entry.getValue());\n            }\n        }\n        jsonReader.nextIfComma();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 35038707531.0,
        "Patch": "import com.alibaba.fastjson2.util.Fnv;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n@@ -139,6 +141,7 @@ final class ObjectReaderSeeAlso<T>\n            }\n        }\n        Map<Long, Object> fieldValues = null;\n        for (int i = 0; ; i++) {\n            if (jsonReader.nextIfObjectEnd()) {\n                if (object == null) {\n@@ -239,9 +242,6 @@ final class ObjectReaderSeeAlso<T>\n            if (object == null) {\n                object = createInstance(jsonReader.getContext().getFeatures() | features);\n                if (object == null) {\n                    throw new JSONException(\"create instance error, objectClass : \" + objectClass);\n                }\n            }\n            if (fieldReader == null) {\n@@ -249,7 +249,22 @@ final class ObjectReaderSeeAlso<T>\n                continue;\n            }\n            fieldReader.readFieldValue(jsonReader, object);\n            if (object == null) {\n                Object fieldValue = fieldReader.readFieldValue(jsonReader);\n                if (fieldValues == null) {\n                    fieldValues = new LinkedHashMap<>();\n                }\n                fieldValues.put(hash, fieldValue);\n            } else {\n                fieldReader.readFieldValue(jsonReader, object);\n            }\n        }\n        if (fieldValues != null) {\n            for (Map.Entry<Long, Object> entry : fieldValues.entrySet()) {\n                FieldReader fieldReader = getFieldReader(entry.getKey());\n                fieldReader.accept(object, entry.getValue());\n            }\n        }\n        jsonReader.nextIfComma();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 35038707675.0,
        "Patch": "import com.alibaba.fastjson2.util.Fnv;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n@@ -139,6 +141,7 @@ final class ObjectReaderSeeAlso<T>\n            }\n        }\n        Map<Long, Object> fieldValues = null;\n        for (int i = 0; ; i++) {\n            if (jsonReader.nextIfObjectEnd()) {\n                if (object == null) {\n@@ -239,9 +242,6 @@ final class ObjectReaderSeeAlso<T>\n            if (object == null) {\n                object = createInstance(jsonReader.getContext().getFeatures() | features);\n                if (object == null) {\n                    throw new JSONException(\"create instance error, objectClass : \" + objectClass);\n                }\n            }\n            if (fieldReader == null) {\n@@ -249,7 +249,22 @@ final class ObjectReaderSeeAlso<T>\n                continue;\n            }\n            fieldReader.readFieldValue(jsonReader, object);\n            if (object == null) {\n                Object fieldValue = fieldReader.readFieldValue(jsonReader);\n                if (fieldValues == null) {\n                    fieldValues = new LinkedHashMap<>();\n                }\n                fieldValues.put(hash, fieldValue);\n            } else {\n                fieldReader.readFieldValue(jsonReader, object);\n            }\n        }\n        if (fieldValues != null) {\n            for (Map.Entry<Long, Object> entry : fieldValues.entrySet()) {\n                FieldReader fieldReader = getFieldReader(entry.getKey());\n                fieldReader.accept(object, entry.getValue());\n            }\n        }\n        jsonReader.nextIfComma();",
        "Label": "NPE_Fix"
    },
    {
        "ID": 35412877847.0,
        "Patch": "16,8 +16,8 @@ import static com.alibaba.fastjson2.util.JDKUtils.*;\nclass JSONReaderASCII\n        extends JSONReaderUTF8 {\n    final String str;\n    static final int ESCAPE_INDEX_NOT_SET = -2;\n    protected int nextEscapeIndex = ESCAPE_INDEX_NOT_SET;\n    boolean checkEscapeFlag = true;\n    int nextEscapeIndex = -1;\n    JSONReaderASCII(Context ctx, String str, byte[] bytes, int offset, int length) {\n        super(ctx, str, bytes, offset, length);\n@@ -1441,9 +1441,19 @@ class JSONReaderASCII\n            if (index == -1) {\n                throw error(\"invalid escape character EOI\");\n            }\n            int slashIndex = index < nextEscapeIndex ? -1 : nextEscapeIndex;\n            if (slashIndex == ESCAPE_INDEX_NOT_SET || (slashIndex != -1 && slashIndex < offset)) {\n                nextEscapeIndex = slashIndex = IOUtils.indexOfChar(bytes, '\\\\', offset, end);\n            int slashIndex = -1;\n            if (checkEscapeFlag) {\n                if (index > nextEscapeIndex) {\n                    if (offset > nextEscapeIndex) {\n                        // scan the nearest '\\\\'\n                        nextEscapeIndex = IOUtils.indexOfChar(bytes, '\\\\', offset, end);  // use end\n                        if ((checkEscapeFlag = nextEscapeIndex > -1) && index > nextEscapeIndex) {\n                            slashIndex = nextEscapeIndex;\n                        }\n                    } else {\n                        slashIndex = nextEscapeIndex;\n                    }\n                }\n            }\n            if (slashIndex == -1) {\n                valueLength = index - offset;",
        "Label": "NPE_Fix"
    },
    {
        "ID": 14610745817.0,
        "Patch": "proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/OpenGaussSystemCatalogAdminQueryExecutor.java\n@@ -88,7 +88,7 @@ public final class OpenGaussSystemCatalogAdminQueryExecutor implements DatabaseA\n            SQLFederationExecutorContext context = new SQLFederationExecutorContext(false, new QueryContext(sqlStatementContext, sql, parameters), metaDataContexts.getMetaData());\n            ShardingSphereDatabase database = metaDataContexts.getMetaData().getDatabase(databaseName);\n            ResultSet resultSet = sqlFederationEngine.executeQuery(prepareEngine,\n                    createOpenGaussSystemCatalogAdminQueryCallback(database.getProtocolType(), database.getResourceMetaData().getStorageTypes(), sqlStatementContext.getSqlStatement()), context);\n                    createOpenGaussSystemCatalogAdminQueryCallback(database.getProtocolType(), database.getResourceMetaData().getStorageUnitTypes(), sqlStatementContext.getSqlStatement()), context);\n            queryResultMetaData = new JDBCQueryResultMetaData(resultSet.getMetaData());\n            mergedResult = new IteratorStreamMergedResult(Collections.singletonList(new JDBCMemoryQueryResult(resultSet, connectionSession.getProtocolType())));\n        }\n@@ -100,7 +100,7 @@ public final class OpenGaussSystemCatalogAdminQueryExecutor implements DatabaseA\n        return new DriverExecutionPrepareEngine<>(JDBCDriverType.STATEMENT, maxConnectionsSizePerQuery, connectionSession.getDatabaseConnectionManager(),\n                connectionSession.getStatementManager(), new StatementOption(false),\n                metaDataContexts.getMetaData().getDatabase(databaseName).getRuleMetaData().getRules(),\n                metaDataContexts.getMetaData().getDatabase(databaseName).getResourceMetaData().getStorageTypes());\n                metaDataContexts.getMetaData().getDatabase(databaseName).getResourceMetaData().getStorageUnitTypes());\n    }\n    private JDBCExecutorCallback<ExecuteResult> createOpenGaussSystemCatalogAdminQueryCallback(final DatabaseType protocolType, final Map<String, DatabaseType> storageTypes,",
        "Label": "NPE_Fix"
    },
    {
        "ID": 14610745722.0,
        "Patch": "public final class OpenGaussSystemCatalogAdminQueryExecutor implements DatabaseA\n            SQLFederationExecutorContext context = new SQLFederationExecutorContext(false, new QueryContext(sqlStatementContext, sql, parameters), metaDataContexts.getMetaData());\n            ShardingSphereDatabase database = metaDataContexts.getMetaData().getDatabase(databaseName);\n            ResultSet resultSet = sqlFederationEngine.executeQuery(prepareEngine,\n                    createOpenGaussSystemCatalogAdminQueryCallback(database.getProtocolType(), database.getResourceMetaData().getStorageTypes(), sqlStatementContext.getSqlStatement()), context);\n                    createOpenGaussSystemCatalogAdminQueryCallback(database.getProtocolType(), database.getResourceMetaData().getStorageUnitTypes(), sqlStatementContext.getSqlStatement()), context);\n            queryResultMetaData = new JDBCQueryResultMetaData(resultSet.getMetaData());\n            mergedResult = new IteratorStreamMergedResult(Collections.singletonList(new JDBCMemoryQueryResult(resultSet, connectionSession.getProtocolType())));\n        }\n@@ -100,7 +100,7 @@ public final class OpenGaussSystemCatalogAdminQueryExecutor implements DatabaseA\n        return new DriverExecutionPrepareEngine<>(JDBCDriverType.STATEMENT, maxConnectionsSizePerQuery, connectionSession.getDatabaseConnectionManager(),\n                connectionSession.getStatementManager(), new StatementOption(false),\n                metaDataContexts.getMetaData().getDatabase(databaseName).getRuleMetaData().getRules(),\n                metaDataContexts.getMetaData().getDatabase(databaseName).getResourceMetaData().getStorageTypes());\n                metaDataContexts.getMetaData().getDatabase(databaseName).getResourceMetaData().getStorageUnitTypes());\n    }\n    private JDBCExecutorCallback<ExecuteResult> createOpenGaussSystemCatalogAdminQueryCallback(final DatabaseType protocolType, final Map<String, DatabaseType> storageTypes,",
        "Label": "NPE_Fix"
    },
    {
        "ID": 1001,
        "Patch": "private void switchToPerspective( final PlaceRequest place,\n                                               LifecyclePhase.OPEN,\n                                               ex );\n             }\n+            existingWorkbenchActivities.remove( newPerspectiveActivity.getPlace() );\n             activityManager.destroyActivity( newPerspectiveActivity );\n         }\n     }",
        "Label": "Not_Null"
    },
    {
        "ID": 1002,
        "Patch": " package org.uberfire.ext.wires.bpmn.api.model;\n \n-import java.util.Set;\n-\n /**\n- * Mar\n+ * Implementations can provide a copy of themselves.\n  */\n public interface Copyable<T> {\n \n-T copy();\n+    T copy();\n \n }",
        "Label": "Not_Null"
    },
    {
        "ID": 1003,
        "Patch": "public BatchCommand( final Command... commands ) {\n+        this.commands = Arrays.asList( PortablePreconditions.checkNotNull( \"commands\",\n+                                                                           commands ) );\n+    }\n+\n+    @Override\n+    public Results apply( final RuleManager ruleManager ) {\n+        final Results results = new DefaultResultsImpl();\n+        final Stack<Command> appliedCommands = new Stack<Command>();\n+        for ( Command command : commands ) {\n+            results.getMessages().addAll( command.apply( ruleManager ).getMessages() );\n+            if ( results.contains( ResultType.ERROR ) ) {\n+                for ( Command undo : appliedCommands ) {\n+                    undo.undo( ruleManager );\n+                }\n+                return results;\n+            } else {\n+                appliedCommands.add( command );\n+            }\n+        }\n+        return results;\n+    }\n+\n+    @Override\n+    public Results undo( final RuleManager ruleManager ) {\n+        final Results results = new DefaultResultsImpl();\n+        final Stack<Command> appliedCommands = new Stack<Command>();\n+        for ( Command command : commands ) {\n+            results.getMessages().addAll( command.undo( ruleManager ).getMessages() );\n+            if ( results.contains( ResultType.ERROR ) ) {\n+                for ( Command cmd : appliedCommands ) {\n+                    cmd.apply( ruleManager );\n+                }\n+                return results;\n+            } else {\n+                appliedCommands.add( command );\n+            }\n+        }\n+        return results;\n+    }\n+\n+}",
        "Label": "Not_Null"
    },
    {
        "ID": 1004,
        "Patch": " import java.io.Closeable;\n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -224,10 +225,11 @@ public void processResult(int rc, String path, Object ctx, byte[] data, Stat sta\n           } catch (Exception e) {\n             break;\n           }\n-          zk.getData(path, false, getTaskForExecutionCallback, new String(data));\n+          zk.getData(path, false, getTaskForExecutionCallback,\n+            new String(data, StandardCharsets.UTF_8));\n           break;\n         case OK:\n-          String cmd = new String(data);\n+          String cmd = new String(data, StandardCharsets.UTF_8);\n           LOG.info(\"Executing command : \" + cmd);\n           String status = ChaosConstants.TASK_COMPLETION_STRING;\n           try {",
        "Label": "Not_Null"
    },
    {
        "ID": 1005,
        "Patch": "public void testAutoCalcFixedOverhead() throws InterruptedException {\n+    List<Class<?>> classList = Arrays.asList(HFileContext.class, HRegion.class, BlockCacheKey.class,\n+      HFileBlock.class, HStore.class, LruBlockCache.class, StoreContext.class);\n+    for (int i = 0; i < 10; i++) {\n+      // warm up\n+      calcFixedOverhead(classList);\n+    }\n+    long startNs = System.nanoTime();\n+    long overhead = 0;\n+    for (int i = 0; i < 100; i++) {\n+      overhead += calcFixedOverhead(classList);\n+    }\n+    long costNs = System.nanoTime() - startNs;\n+    LOG.info(\"overhead = {}, cost {} ns\", overhead, costNs);\n+    // the single computation cost should be less than 5ms\n+    assertThat(costNs, lessThan(TimeUnit.MILLISECONDS.toNanos(5) * classList.size() * 100));\n   }\n }",
        "Label": "Not_Null"
    },
    {
        "ID": 1006,
        "Patch": " package org.apache.hadoop.metrics2.lib;\n \n+import com.google.errorprone.annotations.RestrictedApi;\n import java.util.Collection;\n import java.util.concurrent.ConcurrentMap;\n import org.apache.hadoop.hbase.metrics.Interns;\n@@ -388,8 +389,9 @@ public void removeMetric(String name) {\n \n   public void removeHistogramMetrics(String baseName) {\n     for (String suffix : histogramSuffixes) {\n-      removeMetric(baseName + suffix);\n+      helper.removeObjectName(baseName + suffix);\n     }\n+    metricsMap.remove(baseName);\n   }\n \n   /**",
        "Label": "Not_Null"
    },
    {
        "ID": 1007,
        "Patch": "public void clearMetrics() {\n     }\n     metricsMap.clear();\n   }\n+\n+  @RestrictedApi(explanation = \"Should only be called in TestMetricsTableMetricsMap\", link = \"\",\n+      allowedOnPath = \".*/(DynamicMetricsRegistry|TestMetricsTableMetricsMap).java\")\n+  public ConcurrentMap<String, MutableMetric> getMetricsMap() {\n+    return metricsMap;\n+  }\n }",
        "Label": "Not_Null"
    },
    {
        "ID": 1008,
        "Patch": "public void setRestoredRegion(boolean restoredRegion) {\n   private final int miniBatchSize;\n \n   final ConcurrentHashMap<RegionScanner, Long> scannerReadPoints;\n+  final ReadPointCalculationLock smallestReadPointCalcLock;\n \n   /**\n    * The sequence ID that was enLongAddered when this region was opened.",
        "Label": "Not_Null"
    },
    {
        "ID": 1009,
        "Patch": " public void setRestoredRegion(boolean restoredRegion) {\n    *         this readPoint, are included in every read operation.\n    */\n   public long getSmallestReadPoint() {\n-    long minimumReadPoint;\n     // We need to ensure that while we are calculating the smallestReadPoint\n     // no new RegionScanners can grab a readPoint that we are unaware of.\n-    // We achieve this by synchronizing on the scannerReadPoints object.\n-    synchronized (scannerReadPoints) {\n-      minimumReadPoint = mvcc.getReadPoint();\n+    smallestReadPointCalcLock.lock(ReadPointCalculationLock.LockType.CALCULATION_LOCK);\n+    try {\n+      long minimumReadPoint = mvcc.getReadPoint();\n       for (Long readPoint : this.scannerReadPoints.values()) {\n-        if (readPoint < minimumReadPoint) {\n-          minimumReadPoint = readPoint;\n-        }\n+        minimumReadPoint = Math.min(minimumReadPoint, readPoint);\n       }\n+      return minimumReadPoint;\n+    } finally {\n+      smallestReadPointCalcLock.unlock(ReadPointCalculationLock.LockType.CALCULATION_LOCK);\n     }\n-    return minimumReadPoint;\n   }\n \n   /*",
        "Label": "Not_Null"
    },
    {
        "ID": 1010,
        "Patch": "public HRegion(final HRegionFileSystem fs, final WAL wal, final Configuration co\n     }\n     this.rowLockWaitDuration = tmpRowLockDuration;\n \n+    this.smallestReadPointCalcLock = new ReadPointCalculationLock(conf);\n+\n     this.isLoadingCfsOnDemandDefault = conf.getBoolean(LOAD_CFS_ON_DEMAND_CONFIG_KEY, true);\n     this.htableDescriptor = htd;\n     Set<byte[]> families = this.htableDescriptor.getColumnFamilyNames();",
        "Label": "Not_Null"
    },
    {
        "ID": 1011,
        "Patch": "private void doAttachReplicateRegionReplicaAction(WALKeyImpl walKey, WALEdit wal\n   // 1 x RegionSplitPolicy - splitPolicy\n   // 1 x MetricsRegion - metricsRegion\n   // 1 x MetricsRegionWrapperImpl - metricsRegionWrapper\n+  // 1 x ReadPointCalculationLock - smallestReadPointCalcLock\n   public static final long DEEP_OVERHEAD = FIXED_OVERHEAD + ClassSize.OBJECT + // closeLock\n     (2 * ClassSize.ATOMIC_BOOLEAN) + // closed, closing\n     (3 * ClassSize.ATOMIC_LONG) + // numPutsWithoutWAL, dataInMemoryWithoutWAL,",
        "Label": "Not_Null"
    },
    {
        "ID": 1012,
        "Patch": "public HFileLink(final Path originPath, final Path tempPath, final Path mobPath,\n     this.originPath = originPath;\n     this.mobPath = mobPath;\n     this.archivePath = archivePath;\n-    setLocations(originPath, tempPath, mobPath, archivePath);\n+    setLocations(originPath, archivePath, tempPath, mobPath);\n   }",
        "Label": "Not_Null"
    },
    {
        "ID": 1013,
        "Patch": "public void setSocketSendBufSize(int size) {\n \n   @Override\n   public int getNumOpenConnections() {\n-    int channelsCount = allChannels.size();\n-    // allChannels also contains the server channel, so exclude that from the count.\n-    return channelsCount > 0 ? channelsCount - 1 : channelsCount;\n+    return allChannels.size();\n   }\n \n   private void initSSL(ChannelPipeline p, boolean supportPlaintext)",
        "Label": "Not_Null"
    },
    {
        "ID": 1014,
        "Patch": " private void initializeCellSet(int numOfCells, MemStoreSegmentsIterator iterator\n         offsetInCurentChunk = ChunkCreator.SIZEOF_CHUNK_HEADER;\n       }\n       if (action == MemStoreCompactionStrategy.Action.COMPACT && !alreadyCopied) {\n-        // for compaction copy cell to the new segment (MSLAB copy)\n-        c = maybeCloneWithAllocator(c, false);\n+\n+        // For compaction copy cell to the new segment (MSLAB copy),here we set forceCloneOfBigCell\n+        // to true, because the chunk which the cell is allocated may be freed after the compaction\n+        // is completed, see HBASE-27464.\n+        c = maybeCloneWithAllocator(c, true);\n       }\n       offsetInCurentChunk = // add the Cell reference to the index chunk\n         createCellReference((ByteBufferKeyValue) c, chunks[currentChunkIdx].getData(),",
        "Label": "Not_Null"
    },
    {
        "ID": 1015,
        "Patch": "public List<NormalizationTarget> getNormalizationTargets() {\n     return normalizationTargets;\n   }\n \n+  @Override\n+  public long getPlanSizeMb() {\n+    long total = 0;\n+    for (NormalizationTarget target : normalizationTargets) {\n+      total += target.getRegionSizeMb();\n+    }\n+    return total;\n+  }\n+",
        "Label": "Not_Null"
    },
    {
        "ID": 1016,
        "Patch": "possible configurations would overwhelm and obscure the important.\n     <value>3</value>\n     <description>The minimum age for a region to be considered for a merge, in days.</description>\n   </property>\n-  <property>\n-    <name>hbase.normalizer.merge.min_region_age.days</name>\n-    <value>3</value>\n-    <description>The minimum age for a region to be considered for a merge, in days.</description>\n-  </property>\n   <property>\n     <name>hbase.normalizer.merge.min_region_size.mb</name>\n     <value>1</value>",
        "Label": "Not_Null"
    },
    {
        "ID": 1017,
        "Patch": " public abstract class CleanerChore<T extends FileCleanerDelegate> extends Schedu\n    */\n   public static final String LOG_CLEANER_CHORE_SIZE = \"hbase.log.cleaner.scan.dir.concurrent.size\";\n   static final String DEFAULT_LOG_CLEANER_CHORE_POOL_SIZE = \"1\";\n+  /**\n+   * Enable the CleanerChore to sort the subdirectories by consumed space and start the cleaning\n+   * with the largest subdirectory. Enabled by default.\n+   */\n+  public static final String LOG_CLEANER_CHORE_DIRECTORY_SORTING =\n+    \"hbase.cleaner.directory.sorting\";\n+  static final boolean DEFAULT_LOG_CLEANER_CHORE_DIRECTORY_SORTING = true;\n \n   private final DirScanPool pool;\n ",
        "Label": "Not_Null"
    },
    {
        "ID": 1018,
        "Patch": "public abstract class CleanerChore<T extends FileCleanerDelegate> extends Schedu\n   protected List<String> excludeDirs;\n   private CompletableFuture<Boolean> future;\n   private boolean forceRun;\n+  private boolean sortDirectories;\n \n   public CleanerChore(String name, final int sleepPeriod, final Stoppable s, Configuration conf,\n     FileSystem fs, Path oldFileDir, String confKey, DirScanPool pool) {\n@@ -123,6 +131,8 @@ public CleanerChore(String name, final int sleepPeriod, final Stoppable s, Confi\n     if (excludeDirs != null) {\n       LOG.info(\"Cleaner {} excludes sub dirs: {}\", name, excludeDirs);\n     }\n+    sortDirectories = conf.getBoolean(LOG_CLEANER_CHORE_DIRECTORY_SORTING,\n+      DEFAULT_LOG_CLEANER_CHORE_DIRECTORY_SORTING);\n     initCleanerChain(confKey);\n   }",
        "Label": "Not_Null"
    },
    {
        "ID": 1019,
        "Patch": " public CleanerChore(String name, final int sleepPeriod, final Stoppable s, Confi\n     if (excludeDirs != null) {\n       LOG.info(\"Cleaner {} excludes sub dirs: {}\", name, excludeDirs);\n     }\n+    sortDirectories = conf.getBoolean(LOG_CLEANER_CHORE_DIRECTORY_SORTING,\n+      DEFAULT_LOG_CLEANER_CHORE_DIRECTORY_SORTING);\n     initCleanerChain(confKey);\n   }",
        "Label": "Not_Null"
    },
    {
        "ID": 1020,
        "Patch": " private void traverseAndDelete(Path dir, boolean root, CompletableFuture<Boolean\n       // Step.3: Start to traverse and delete the sub-directories.\n       List<CompletableFuture<Boolean>> futures = new ArrayList<>();\n       if (!subDirs.isEmpty()) {\n-        sortByConsumedSpace(subDirs);\n+        if (sortDirectories) {\n+          sortByConsumedSpace(subDirs);\n+        }\n         // Submit the request of sub-directory deletion.\n         subDirs.forEach(subDir -> {\n           if (!shouldExclude(subDir)) {",
        "Label": "Not_Null"
    },
    {
        "ID": 1021,
        "Patch": "public class AsyncConnectionImpl implements AsyncConnection {\n \n   private final AtomicBoolean closed = new AtomicBoolean(false);\n \n+  private final String metricsScope;\n   private final Optional<MetricsConnection> metrics;\n \n   private final ClusterStatusListener clusterStatusListener;",
        "Label": "Not_Null"
    },
    {
        "ID": 1022,
        "Patch": "public AsyncConnectionImpl(Configuration conf, ConnectionRegistry registry, Stri\n     SocketAddress localAddress, User user) {\n     this.conf = conf;\n     this.user = user;\n+    this.metricsScope = MetricsConnection.getScope(conf, clusterId, this);\n \n     if (user.isLoginFromKeytab()) {\n       spawnRenewalChore(user.getUGI());\n     }\n     this.connConf = new AsyncConnectionConfiguration(conf);\n     this.registry = registry;\n     if (conf.getBoolean(CLIENT_SIDE_METRICS_ENABLED_KEY, false)) {\n-      String scope = MetricsConnection.getScope(conf, clusterId, this);\n-      this.metrics = Optional.of(new MetricsConnection(scope, () -> null, () -> null));\n+      this.metrics =\n+        Optional.of(MetricsConnection.getMetricsConnection(metricsScope, () -> null, () -> null));\n     } else {\n       this.metrics = Optional.empty();\n     }",
        "Label": "Not_Null"
    },
    {
        "ID": 1023,
        "Patch": "public abstract class RpcServer implements RpcServerInterface, ConfigurationObse\n   private static final String MULTI_SERVICE_CALLS = \"multi.service_calls\";\n \n   private final boolean authorize;\n-  private final boolean isOnlineLogProviderEnabled;\n+  private volatile boolean isOnlineLogProviderEnabled;\n   protected boolean isSecurityEnabled;\n \n   public static final byte CURRENT_VERSION = 0;",
        "Label": "Not_Null"
    },
    {
        "ID": 1024,
        "Patch": "public abstract class RpcServer implements RpcServerInterface, ConfigurationObse\n   protected static final Gson GSON = GsonUtil.createGsonWithDisableHtmlEscaping().create();\n \n   protected final int maxRequestSize;\n-  protected final int warnResponseTime;\n-  protected final int warnResponseSize;\n+  protected volatile int warnResponseTime;\n+  protected volatile int warnResponseSize;\n \n   protected final int minClientRequestTimeout;\n \n@@ -275,8 +275,8 @@ public RpcServer(final Server server, final String name,\n     this.maxQueueSizeInBytes =\n       this.conf.getLong(\"hbase.ipc.server.max.callqueue.size\", DEFAULT_MAX_CALLQUEUE_SIZE);\n \n-    this.warnResponseTime = conf.getInt(WARN_RESPONSE_TIME, DEFAULT_WARN_RESPONSE_TIME);\n-    this.warnResponseSize = conf.getInt(WARN_RESPONSE_SIZE, DEFAULT_WARN_RESPONSE_SIZE);\n+    this.warnResponseTime = getWarnResponseTime(conf);\n+    this.warnResponseSize = getWarnResponseSize(conf);\n     this.minClientRequestTimeout =\n       conf.getInt(MIN_CLIENT_REQUEST_TIMEOUT, DEFAULT_MIN_CLIENT_REQUEST_TIMEOUT);\n     this.maxRequestSize = conf.getInt(MAX_REQUEST_SIZE, DEFAULT_MAX_REQUEST_SIZE);\n@@ -297,8 +297,7 @@ public RpcServer(final Server server, final String name,\n       saslProps = Collections.emptyMap();\n     }\n \n-    this.isOnlineLogProviderEnabled = conf.getBoolean(HConstants.SLOW_LOG_BUFFER_ENABLED_KEY,\n-      HConstants.DEFAULT_ONLINE_LOG_PROVIDER_ENABLED);\n+    this.isOnlineLogProviderEnabled = getIsOnlineLogProviderEnabled(conf);\n     this.scheduler = scheduler;\n   }\n \n@@ -311,6 +310,35 @@ public void onConfigurationChange(Configuration newConf) {\n     if (authorize) {\n       refreshAuthManager(newConf, new HBasePolicyProvider());\n     }\n+    refreshSlowLogConfiguration(newConf);\n+  }\n+\n+  private void refreshSlowLogConfiguration(Configuration newConf) {\n+    boolean newIsOnlineLogProviderEnabled = getIsOnlineLogProviderEnabled(newConf);\n+    if (isOnlineLogProviderEnabled != newIsOnlineLogProviderEnabled) {\n+      isOnlineLogProviderEnabled = newIsOnlineLogProviderEnabled;\n+    }\n+    int newWarnResponseTime = getWarnResponseTime(newConf);\n+    if (warnResponseTime != newWarnResponseTime) {\n+      warnResponseTime = newWarnResponseTime;\n+    }\n+    int newWarnResponseSize = getWarnResponseSize(newConf);\n+    if (warnResponseSize != newWarnResponseSize) {\n+      warnResponseSize = newWarnResponseSize;\n+    }\n+  }\n+\n+  private static boolean getIsOnlineLogProviderEnabled(Configuration conf) {\n+    return conf.getBoolean(HConstants.SLOW_LOG_BUFFER_ENABLED_KEY,\n+      HConstants.DEFAULT_ONLINE_LOG_PROVIDER_ENABLED);\n+  }\n+\n+  private static int getWarnResponseTime(Configuration conf) {\n+    return conf.getInt(WARN_RESPONSE_TIME, DEFAULT_WARN_RESPONSE_TIME);\n+  }\n+\n+  private static int getWarnResponseSize(Configuration conf) {\n+    return conf.getInt(WARN_RESPONSE_SIZE, DEFAULT_WARN_RESPONSE_SIZE);\n   }\n \n   protected void initReconfigurable(Configuration confToLoad) {",
        "Label": "Not_Null"
    },
    {
        "ID": 1025,
        "Patch": "public static CloseRegionRequest buildCloseRegionRequest(ServerName server, byte\n   }\n \n   public static CloseRegionRequest buildCloseRegionRequest(ServerName server, byte[] regionName,\n+    ServerName destinationServer, long closeProcId) {\n+    return ProtobufUtil.getBuilder(server, regionName, destinationServer, closeProcId).build();\n+  }\n+\n+  public static CloseRegionRequest buildCloseRegionRequest(ServerName server, byte[] regionName,\n+    ServerName destinationServer, long closeProcId, boolean evictCache) {\n+    CloseRegionRequest.Builder builder =\n+      getBuilder(server, regionName, destinationServer, closeProcId);\n+    builder.setEvictCache(evictCache);\n+    return builder.build();\n+  }\n+\n+  public static CloseRegionRequest.Builder getBuilder(ServerName server, byte[] regionName,\n     ServerName destinationServer, long closeProcId) {\n     CloseRegionRequest.Builder builder = CloseRegionRequest.newBuilder();\n     RegionSpecifier region =",
        "Label": "Not_Null"
    },
    {
        "ID": 1026,
        "Patch": " public static CloseRegionRequest buildCloseRegionRequest(ServerName server, byte\n       builder.setServerStartCode(server.getStartcode());\n     }\n     builder.setCloseProcId(closeProcId);\n-    return builder.build();\n+    return builder;\n   }\n \n   public static ProcedureDescription buildProcedureDescription(String signature, String instance,",
        "Label": "Not_Null"
    },
    {
        "ID": 1017,
        "Patch": " public abstract class CleanerChore<T extends FileCleanerDelegate> extends Schedu\n    */\n   public static final String LOG_CLEANER_CHORE_SIZE = \"hbase.log.cleaner.scan.dir.concurrent.size\";\n   static final String DEFAULT_LOG_CLEANER_CHORE_POOL_SIZE = \"1\";\n+  /**\n+   * Enable the CleanerChore to sort the subdirectories by consumed space and start the cleaning\n+   * with the largest subdirectory. Enabled by default.\n+   */\n+  public static final String LOG_CLEANER_CHORE_DIRECTORY_SORTING =\n+    \"hbase.cleaner.directory.sorting\";\n+  static final boolean DEFAULT_LOG_CLEANER_CHORE_DIRECTORY_SORTING = true;\n \n   private final DirScanPool pool;\n ",
        "Label": "Not_Null"
    },
    {
        "ID": 1018,
        "Patch": "public abstract class CleanerChore<T extends FileCleanerDelegate> extends Schedu\n   protected List<String> excludeDirs;\n   private CompletableFuture<Boolean> future;\n   private boolean forceRun;\n+  private boolean sortDirectories;\n \n   public CleanerChore(String name, final int sleepPeriod, final Stoppable s, Configuration conf,\n     FileSystem fs, Path oldFileDir, String confKey, DirScanPool pool) {\n@@ -123,6 +131,8 @@ public CleanerChore(String name, final int sleepPeriod, final Stoppable s, Confi\n     if (excludeDirs != null) {\n       LOG.info(\"Cleaner {} excludes sub dirs: {}\", name, excludeDirs);\n     }\n+    sortDirectories = conf.getBoolean(LOG_CLEANER_CHORE_DIRECTORY_SORTING,\n+      DEFAULT_LOG_CLEANER_CHORE_DIRECTORY_SORTING);\n     initCleanerChain(confKey);\n   }",
        "Label": "Not_Null"
    },
    {
        "ID": 1019,
        "Patch": " public CleanerChore(String name, final int sleepPeriod, final Stoppable s, Confi\n     if (excludeDirs != null) {\n       LOG.info(\"Cleaner {} excludes sub dirs: {}\", name, excludeDirs);\n     }\n+    sortDirectories = conf.getBoolean(LOG_CLEANER_CHORE_DIRECTORY_SORTING,\n+      DEFAULT_LOG_CLEANER_CHORE_DIRECTORY_SORTING);\n     initCleanerChain(confKey);\n   }",
        "Label": "Not_Null"
    },
    {
        "ID": 1020,
        "Patch": " private void traverseAndDelete(Path dir, boolean root, CompletableFuture<Boolean\n       // Step.3: Start to traverse and delete the sub-directories.\n       List<CompletableFuture<Boolean>> futures = new ArrayList<>();\n       if (!subDirs.isEmpty()) {\n-        sortByConsumedSpace(subDirs);\n+        if (sortDirectories) {\n+          sortByConsumedSpace(subDirs);\n+        }\n         // Submit the request of sub-directory deletion.\n         subDirs.forEach(subDir -> {\n           if (!shouldExclude(subDir)) {",
        "Label": "Not_Null"
    },
    {
        "ID": 1021,
        "Patch": "public class AsyncConnectionImpl implements AsyncConnection {\n \n   private final AtomicBoolean closed = new AtomicBoolean(false);\n \n+  private final String metricsScope;\n   private final Optional<MetricsConnection> metrics;\n \n   private final ClusterStatusListener clusterStatusListener;",
        "Label": "Not_Null"
    },
    {
        "ID": 1027,
        "Patch": "static String getScope(Configuration conf, String clusterId, Object connectionOb\n   }\n \n   private static final String CNT_BASE = \"rpcCount_\";\n+  private static final String FAILURE_CNT_BASE = \"rpcFailureCount_\";\n   private static final String DRTN_BASE = \"rpcCallDurationMs_\";\n   private static final String REQ_BASE = \"rpcCallRequestSizeBytes_\";\n   private static final String RESP_BASE = \"rpcCallResponseSizeBytes_\";",
        "Label": "Not_Null"
    },
    {
        "ID": 1028,
        "Patch": "private void shutdown() {\n   }\n \n   /** Report RPC context to metrics system. */\n-  public void updateRpc(MethodDescriptor method, Message param, CallStats stats) {\n+  public void updateRpc(MethodDescriptor method, Message param, CallStats stats, boolean failed) {\n     int callsPerServer = stats.getConcurrentCallsPerServer();\n     if (callsPerServer > 0) {\n       concurrentCallsPerServerHist.update(callsPerServer);\n     }\n     // Update the counter that tracks RPCs by type.\n     final String methodName = method.getService().getName() + \"_\" + method.getName();\n     getMetric(CNT_BASE + methodName, rpcCounters, counterFactory).inc();\n+    if (failed) {\n+      getMetric(FAILURE_CNT_BASE + methodName, rpcCounters, counterFactory).inc();\n+    }\n     // this implementation is tied directly to protobuf implementation details. would be better\n     // if we could dispatch based on something static, ie, request Message type.\n     if (method.getService() == ClientService.getDescriptor()) {",
        "Label": "Not_Null"
    },
    {
        "ID": 1029,
        "Patch": "public HFileBlock getMetaBlock(String metaBlockName, boolean cacheBlock) throws\n   }\n \n   /**\n-   * If expected block is data block, we'll allocate the ByteBuff of block from\n-   * {@link org.apache.hadoop.hbase.io.ByteBuffAllocator} and it's usually an off-heap one,\n-   * otherwise it will allocate from heap.\n+   * Whether we use heap or not depends on our intent to cache the block. We want to avoid\n+   * allocating to off-heap if we intend to cache into the on-heap L1 cache. Otherwise, it's more\n+   * efficient to allocate to off-heap since we can control GC ourselves for those. So our decision\n+   * here breaks down as follows: <br>\n+   * If block cache is disabled, don't use heap. If we're not using the CombinedBlockCache, use heap\n+   * unless caching is disabled for the request. Otherwise, only use heap if caching is enabled and\n+   * the expected block type is not DATA (which goes to off-heap L2 in combined cache).\n    * @see org.apache.hadoop.hbase.io.hfile.HFileBlock.FSReader#readBlockData(long, long, boolean,\n    *      boolean, boolean)\n    */\n-  private boolean shouldUseHeap(BlockType expectedBlockType) {\n+  private boolean shouldUseHeap(BlockType expectedBlockType, boolean cacheBlock) {\n     if (!cacheConf.getBlockCache().isPresent()) {\n       return false;\n-    } else if (!cacheConf.isCombinedBlockCache()) {\n-      // Block to cache in LruBlockCache must be an heap one. So just allocate block memory from\n-      // heap for saving an extra off-heap to heap copying.\n-      return true;\n     }\n-    return expectedBlockType != null && !expectedBlockType.isData();\n+\n+    // we only cache a block if cacheBlock is true and caching-on-read is enabled in CacheConfig\n+    // we can really only check for that if have an expectedBlockType\n+    if (expectedBlockType != null) {\n+      cacheBlock &= cacheConf.shouldCacheBlockOnRead(expectedBlockType.getCategory());\n+    }\n+\n+    if (!cacheConf.isCombinedBlockCache()) {\n+      // Block to cache in LruBlockCache must be an heap one, if caching enabled. So just allocate\n+      // block memory from heap for saving an extra off-heap to heap copying in that case.\n+      return cacheBlock;\n+    }",
        "Label": "Not_Null"
    },
    {
        "ID": 1030,
        "Patch": "public HFileBlock readBlock(long dataBlockOffset, long onDiskBlockSize, final bo\n         span.addEvent(\"block cache miss\", attributes);\n         // Load block from filesystem.\n         HFileBlock hfileBlock = fsBlockReader.readBlockData(dataBlockOffset, onDiskBlockSize, pread,\n-          !isCompaction, shouldUseHeap(expectedBlockType));\n-        validateBlockType(hfileBlock, expectedBlockType);\n+          !isCompaction, shouldUseHeap(expectedBlockType, cacheable));\n+        try {\n+          validateBlockType(hfileBlock, expectedBlockType);\n+        } catch (IOException e) {\n+          hfileBlock.release();\n+          throw e;\n+        }\n         BlockType.BlockCategory category = hfileBlock.getBlockType().getCategory();\n         final boolean cacheCompressed = cacheConf.shouldCacheCompressed(category);\n         final boolean cacheOnRead = cacheConf.shouldCacheBlockOnRead(category);",
        "Label": "Not_Null"
    },
    {
        "ID": 1031,
        "Patch": "public class ZNodePaths {\n   // znode used for log splitting work assignment\n   public final String splitLogZNode;\n   // znode containing the state of the load balancer\n+  /**\n+   * @deprecated Since 2.6.0, will be removed in 4.0.0. We use master local region to store this\n+   *             state.\n+   */\n+  @Deprecated\n   public final String balancerZNode;\n   // znode containing the state of region normalizer\n+  /**\n+   * @deprecated Since 2.6.0, will be removed in 4.0.0. We use master local region to store this\n+   *             state.\n+   */\n+  @Deprecated\n   public final String regionNormalizerZNode;\n   // znode containing the state of all switches, currently there are split and merge child node.\n+  /**\n+   * @deprecated Since 2.6.0, will be removed in 4.0.0. We use master local region to store this\n+   *             state.\n+   */\n+  @Deprecated\n   public final String switchZNode;\n   // znode of indicating master maintenance mode\n   public final String masterMaintZNode;",
        "Label": "Not_Null"
    },
    {
        "ID": 1032,
        "Patch": "  public final String regionNormalizerZNode;\n   // znode containing the state of all switches, currently there are split and merge child node.\n+  /**\n+   * @deprecated Since 2.6.0, will be removed in 4.0.0. We use master local region to store this\n+   *             state.\n+   */\n+  @Deprecated\n   public final String switchZNode;\n   // znode of indicating master maintenance mode\n   public final String masterMaintZNode;\n public class ZNodePaths {\n   // znode containing queues of hfile references to be replicated\n   public final String hfileRefsZNode;\n   // znode containing the state of the snapshot auto-cleanup\n-  final String snapshotCleanupZNode;\n+  /**\n+   * @deprecated Since 2.6.0, will be removed in 4.0.0. We use master local region to store this\n+   *             state.\n+   */\n+  @Deprecated\n+  public final String snapshotCleanupZNode;\n \n   public ZNodePaths(Configuration conf) {\n     baseZNode = conf.get(ZOOKEEPER_ZNODE_PARENT, DEFAULT_ZOOKEEPER_ZNODE_PARENT);",
        "Label": "Not_Null"
    },
    {
        "ID": 1033,
        "Patch": " public static String parseHostFromOldLog(Path p) {\n+    // Skip master wals\n+    if (p.getName().endsWith(MasterRegionFactory.ARCHIVED_WAL_SUFFIX)) {\n+      return null;\n+    }\n     try {\n       String n = p.getName();\n       int idx = n.lastIndexOf(LOGNAME_SEPARATOR);",
        "Label": "Not_Null"
    },
    {
        "ID": 1034,
        "Patch": "logger.MetricsConfig.level = WARN\n logger.MetricsSinkAdapter.name = org.apache.hadoop.metrics2.impl.MetricsSinkAdapter\n logger.MetricsSinkAdapter.level = WARN\n \n+# These two settings are workarounds against spurious logs from the minicluster.\n+# See HBASE-4709\n logger.MetricsSystemImpl.name = org.apache.hadoop.metrics2.impl.MetricsSystemImpl\n-logger.MetricsSystemImpl.level = WARN\n+logger.MetricsSystemImpl.level = ERROR\n \n logger.MBeans.name = org.apache.hadoop.metrics2.util.MBeans\n-logger.MBeans.level = WARN\n+logger.MBeans.level = ERROR\n \n logger.directory.name = org.apache.directory\n logger.directory.level = WARN",
        "Label": "Not_Null"
    },
    {
        "ID": 1035,
        "Patch": "logger.RSRpcServices.level = DEBUG\n \n logger.TestJul2Slf4j.name = org.apache.hadoop.hbase.logging.TestJul2Slf4j\n logger.TestJul2Slf4j.level = DEBUG\n+\n+# Avoid log flooded with chore execution time, see HBASE-24646 for more details.\n+logger.ScheduledChore.name = org.apache.hadoop.hbase.ScheduledChore\n+logger.ScheduledChore.level = INFO",
        "Label": "Not_Null"
    },
    {
        "ID": 1036,
        "Patch": " private RegionInfo metaTableConsistencyCheck(Result metaTableRow) {\n           addOverlap(this.highestEndKeyRegionInfo, ri);\n         }\n       }\n+      this.previous = ri;\n+      this.highestEndKeyRegionInfo =\n+        MetaFixer.getRegionInfoWithLargestEndKey(this.highestEndKeyRegionInfo, ri);\n     }\n-    this.previous = ri;\n-    this.highestEndKeyRegionInfo =\n-      MetaFixer.getRegionInfoWithLargestEndKey(this.highestEndKeyRegionInfo, ri);\n     return ri;\n   }\n ",
        "Label": "Not_Null"
    },
    {
        "ID": 1037,
        "Patch": "public class ChoreService {\n    */\n   @InterfaceAudience.Private\n   public final static int MIN_CORE_POOL_SIZE = 1;\n+  /**\n+   * The initial number of threads in the core pool for the {@link ChoreService}.\n+   */\n+  public static final String CHORE_SERVICE_INITIAL_POOL_SIZE =\n+    \"hbase.choreservice.initial.pool.size\";\n+  public static final int DEFAULT_CHORE_SERVICE_INITIAL_POOL_SIZE = 1;\n \n   /**\n    * This thread pool is used to schedule all of the Chores",
        "Label": "Not_Null"
    },
    {
        "ID": 1038,
        "Patch": " public class PolicyBasedChaosMonkey extends ChaosMonkey {\n+  private static final Logger LOG = LoggerFactory.getLogger(PolicyBasedChaosMonkey.class);\n \n   private static final long ONE_SEC = 1000;\n   private static final long ONE_MIN = 60 * ONE_SEC;",
        "Label": "Not_Null"
    },
    {
        "ID": 1039,
        "Patch": "public static <T> T selectWeightedRandomItem(List<Pair<T, Integer>> items) {\n \n   /** Selects and returns ceil(ratio * items.length) random items from the given array */\n   public static <T> List<T> selectRandomItems(T[] items, float ratio) {\n-    int selectedNumber = (int) Math.ceil(items.length * ratio);\n-\n-    List<T> originalItems = Arrays.asList(items);\n-    Collections.shuffle(originalItems);\n-\n-    int startIndex = ThreadLocalRandom.current().nextInt(items.length - selectedNumber);\n-    return originalItems.subList(startIndex, startIndex + selectedNumber);\n+    // clamp ratio to [0.0,1.0]\n+    ratio = Math.max(Math.min(ratio, 1.0f), 0.0f);\n+    final int selectedNumber = (int) Math.ceil(items.length * ratio);\n+    final ReservoirSample<T> sample = new ReservoirSample<>(selectedNumber);\n+    sample.add(Arrays.stream(items));\n+    final List<T> shuffledItems = sample.getSamplingResult();\n+    Collections.shuffle(shuffledItems);\n+    return shuffledItems;\n   }",
        "Label": "Not_Null"
    },
    {
        "ID": 1040,
        "Patch": "public void waitForStop() throws InterruptedException {\n-    monkeyThreadPool.awaitTermination(1, TimeUnit.MINUTES);\n+    if (!monkeyThreadPool.awaitTermination(1, TimeUnit.MINUTES)) {\n+      LOG.warn(\"Some pool threads failed to terminate. Forcing. {}\", monkeyThreadPool);\n+      monkeyThreadPool.shutdownNow();\n+    }\n   }\n ",
        "Label": "Not_Null"
    },
    {
        "ID": 1041,
        "Patch": " public class MasterRegistry extends AbstractRpcBasedConnectionRegistry {\n \n   private static final String MASTER_ADDRS_CONF_SEPARATOR = \",\";\n \n+  /**\n+   * Supplies the default master port we should use given the provided configuration.\n+   * @param conf Configuration to parse from.\n+   */\n+  private static int getDefaultMasterPort(Configuration conf) {\n+    final int port = conf.getInt(HConstants.MASTER_PORT, HConstants.DEFAULT_MASTER_PORT);\n+    if (port == 0) {\n+      // Master port may be set to 0. We should substitute the default port in that case.\n+      return HConstants.DEFAULT_MASTER_PORT;\n+    }\n+    return port;\n+  }\n+\n   /**\n    * Parses the list of master addresses from the provided configuration. Supported format is comma\n    * separated host[:port] values. If no port number if specified, default master port is assumed.\n    * @param conf Configuration to parse from.\n    */\n   public static Set<ServerName> parseMasterAddrs(Configuration conf) throws UnknownHostException {\n-    Set<ServerName> masterAddrs = new HashSet<>();\n-    String configuredMasters = getMasterAddr(conf);\n+    final int defaultPort = getDefaultMasterPort(conf);\n+    final Set<ServerName> masterAddrs = new HashSet<>();\n+    final String configuredMasters = getMasterAddr(conf);\n     for (String masterAddr : Splitter.onPattern(MASTER_ADDRS_CONF_SEPARATOR)\n       .split(configuredMasters)) {\n-      HostAndPort masterHostPort =\n-        HostAndPort.fromString(masterAddr.trim()).withDefaultPort(HConstants.DEFAULT_MASTER_PORT);\n+      final HostAndPort masterHostPort =\n+        HostAndPort.fromString(masterAddr.trim()).withDefaultPort(defaultPort);\n       masterAddrs.add(ServerName.valueOf(masterHostPort.toString(), ServerName.NON_STARTCODE));\n     }\n     Preconditions.checkArgument(!masterAddrs.isEmpty(), \"At least one master address is needed\");",
        "Label": "Not_Null"
    },
    {
        "ID": 1042,
        "Patch": " public interface RestoreJob extends Configurable {\n    * Run restore operation\n    * @param dirPaths          path array of WAL log directories\n    * @param fromTables        from tables\n+   * @param restoreRootDir    output file system\n    * @param toTables          to tables\n    * @param fullBackupRestore full backup restore\n    * @throws IOException if running the job fails\n    */\n-  void run(Path[] dirPaths, TableName[] fromTables, TableName[] toTables, boolean fullBackupRestore)\n-    throws IOException;\n+  void run(Path[] dirPaths, TableName[] fromTables, Path restoreRootDir, TableName[] toTables,\n+    boolean fullBackupRestore) throws IOException;\n }",
        "Label": "Not_Null"
    },
    {
        "ID": 1043,
        "Patch": "private void checkIsDead(final ServerName serverName, final String what)\n    * Assumes onlineServers is locked.\n    * @return ServerName with matching hostname and port.\n    */\n-  private ServerName findServerWithSameHostnamePortWithLock(final ServerName serverName) {\n+  public ServerName findServerWithSameHostnamePortWithLock(final ServerName serverName) {\n     ServerName end =\n       ServerName.valueOf(serverName.getHostname(), serverName.getPort(), Long.MAX_VALUE);\n ",
        "Label": "Not_Null"
    },
    {
        "ID": 1044,
        "Patch": "function hbaseprotoc_rebuild\n   # Need to run 'install' instead of 'compile' because shading plugin\n   # is hooked-up to 'install'; else hbase-protocol-shaded is left with\n   # half of its process done.\n-  modules_workers patch hbaseprotoc install -DskipTests -X -DHBasePatchProcess\n+  modules_workers patch hbaseprotoc install -DskipTests -DHBasePatchProcess\n \n   # shellcheck disable=SC2153\n   until [[ $i -eq \"${#MODULE[@]}\" ]]; do",
        "Label": "Not_Null"
    },
    {
        "ID": 1045,
        "Patch": "public static Class<? extends StoreFileTracker> getTrackerClass(String trackerNa\n   public static StoreFileTracker create(Configuration conf, boolean isPrimaryReplica,\n     StoreContext ctx) {\n     Class<? extends StoreFileTracker> tracker = getTrackerClass(conf);\n-    LOG.info(\"instantiating StoreFileTracker impl {}\", tracker.getName());\n+    LOG.debug(\"instantiating StoreFileTracker impl {}\", tracker.getName());\n     return ReflectionUtils.newInstance(tracker, conf, isPrimaryReplica, ctx);\n   }",
        "Label": "Not_Null"
    },
    {
        "ID": 1046,
        "Patch": " static StoreFileTrackerBase createForMigration(Configuration conf, String config\n       throw new IllegalArgumentException(\"Should not specify \" + configName + \" as \"\n         + Trackers.MIGRATION + \" because it can not be nested\");\n     }\n-    LOG.info(\"instantiating StoreFileTracker impl {} as {}\", tracker.getName(), configName);\n+    LOG.debug(\"instantiating StoreFileTracker impl {} as {}\", tracker.getName(), configName);\n     return ReflectionUtils.newInstance(tracker, conf, isPrimaryReplica, ctx);\n   }\n ",
        "Label": "Not_Null"
    },
    {
        "ID": 1047,
        "Patch": "public static HRegion openReadOnlyFileSystemHRegion(final Configuration conf, fi\n     return r.openHRegion(null);\n   }\n \n-  public static void warmupHRegion(final RegionInfo info, final TableDescriptor htd, final WAL wal,\n-    final Configuration conf, final RegionServerServices rsServices,\n+  public static HRegion warmupHRegion(final RegionInfo info, final TableDescriptor htd,\n+    final WAL wal, final Configuration conf, final RegionServerServices rsServices,\n     final CancelableProgressable reporter) throws IOException {\n \n     Objects.requireNonNull(info, \"RegionInfo cannot be null\");",
        "Label": "Not_Null"
    },
    {
        "ID": 1048,
        "Patch": " public void filterRowCells(List<Cell> ignored) throws IOException {\n   }\n \n   /**\n-   * Fitlers that never filter by modifying the returned List of Cells can inherit this\n+   * Filters that never filter by modifying the returned List of Cells can inherit this\n    * implementation that does nothing. {@inheritDoc}\n    */\n   @Override",
        "Label": "Not_Null"
    },
    {
        "ID": 1049,
        "Patch": "public void close() {\n       public void shipped() throws IOException {\n         this.delegate.shipped();\n       }\n+\n+      @Override\n+      public void recordBlockSize(IntConsumer blockSizeConsumer) {\n+        this.delegate.recordBlockSize(blockSizeConsumer);\n+      }\n     };\n   }\n ",
        "Label": "Not_Null"
    },
    {
        "ID": 1050,
        "Patch": "public void run() {\n               threadGroup.setDaemon(false);\n             }\n           }\n+        } catch (NoSuchFieldException e) {\n+          LOG.debug(\"NoSuchFieldException: \" + e.getMessage()\n+            + \"; It might because your Hadoop version > 3.2.3 or 3.3.4, \"\n+            + \"See HBASE-27595 for details.\");\n         } catch (Exception e) {\n           LOG.warn(\"failed to reset thread pool timeout for FsDatasetAsyncDiskService\", e);\n         }",
        "Label": "Not_Null"
    },
    {
        "ID": 1051,
        "Patch": " final public class OnlineLogRecord extends LogEntry {\n   private final int processingTime;\n   private final int queueTime;\n   private final long responseSize;\n+  private final long blockBytesScanned;\n   private final String clientAddress;\n   private final String serverClass;\n   private final String methodName;",
        "Label": "Not_Null"
    },
    {
        "ID": 1052,
        "Patch": " public long getResponseSize() {\n     return responseSize;\n   }\n \n+  /**\n+   * Return the amount of block bytes scanned to retrieve the response cells.\n+   */\n+  public long getBlockBytesScanned() {\n+    return blockBytesScanned;\n+  }\n+\n   public String getClientAddress() {\n     return clientAddress;\n   }",
        "Label": "Not_Null"
    },
    {
        "ID": 1053,
        "Patch": " public int getMultiServiceCalls() {\n   }\n \n   private OnlineLogRecord(final long startTime, final int processingTime, final int queueTime,\n-    final long responseSize, final String clientAddress, final String serverClass,\n-    final String methodName, final String callDetails, final String param, final String regionName,\n-    final String userName, final int multiGetsCount, final int multiMutationsCount,\n-    final int multiServiceCalls) {\n+    final long responseSize, final long blockBytesScanned, final String clientAddress,\n+    final String serverClass, final String methodName, final String callDetails, final String param,\n+    final String regionName, final String userName, final int multiGetsCount,\n+    final int multiMutationsCount, final int multiServiceCalls) {\n     this.startTime = startTime;\n     this.processingTime = processingTime;\n     this.queueTime = queueTime;\n     this.responseSize = responseSize;\n+    this.blockBytesScanned = blockBytesScanned;\n     this.clientAddress = clientAddress;\n     this.serverClass = serverClass;\n     this.methodName = methodName;",
        "Label": "Not_Null"
    },
    {
        "ID": 1054,
        "Patch": " public static class OnlineLogRecordBuilder {\n     private int processingTime;\n     private int queueTime;\n     private long responseSize;\n+    private long blockBytesScanned;\n     private String clientAddress;\n     private String serverClass;\n     private String methodName;\n@@ -185,6 +195,14 @@ public OnlineLogRecordBuilder setResponseSize(long responseSize) {\n       return this;\n     }\n \n+    /**\n+     * Sets the amount of block bytes scanned to retrieve the response cells.\n+     */\n+    public OnlineLogRecordBuilder setBlockBytesScanned(long blockBytesScanned) {\n+      this.blockBytesScanned = blockBytesScanned;\n+      return this;\n+    }\n+\n     public OnlineLogRecordBuilder setClientAddress(String clientAddress) {\n       this.clientAddress = clientAddress;\n       return this;",
        "Label": "Not_Null"
    },
    {
        "ID": 1055,
        "Patch": " public OnlineLogRecordBuilder setResponseSize(long responseSize) {\n       return this;\n     }\n \n+    /**\n+     * Sets the amount of block bytes scanned to retrieve the response cells.\n+     */\n+    public OnlineLogRecordBuilder setBlockBytesScanned(long blockBytesScanned) {\n+      this.blockBytesScanned = blockBytesScanned;\n+      return this;\n+    }\n+\n     public OnlineLogRecordBuilder setClientAddress(String clientAddress) {\n       this.clientAddress = clientAddress;\n       return this;",
        "Label": "Not_Null"
    },
    {
        "ID": 1056,
        "Patch": "public OnlineLogRecordBuilder setMultiServiceCalls(int multiServiceCalls) {\n     }\n \n     public OnlineLogRecord build() {\n-      return new OnlineLogRecord(startTime, processingTime, queueTime, responseSize, clientAddress,\n-        serverClass, methodName, callDetails, param, regionName, userName, multiGetsCount,\n-        multiMutationsCount, multiServiceCalls);\n+      return new OnlineLogRecord(startTime, processingTime, queueTime, responseSize,\n+        blockBytesScanned, clientAddress, serverClass, methodName, callDetails, param, regionName,\n+        userName, multiGetsCount, multiMutationsCount, multiServiceCalls);\n     }\n   }\n ",
        "Label": "Not_Null"
    },
    {
        "ID": 1057,
        "Patch": " public boolean equals(Object o) {\n \n     return new EqualsBuilder().append(startTime, that.startTime)\n       .append(processingTime, that.processingTime).append(queueTime, that.queueTime)\n-      .append(responseSize, that.responseSize).append(multiGetsCount, that.multiGetsCount)\n+      .append(responseSize, that.responseSize).append(blockBytesScanned, that.blockBytesScanned)\n+      .append(multiGetsCount, that.multiGetsCount)\n       .append(multiMutationsCount, that.multiMutationsCount)\n       .append(multiServiceCalls, that.multiServiceCalls).append(clientAddress, that.clientAddress)\n       .append(serverClass, that.serverClass).append(methodName, that.methodName)",
        "Label": "Not_Null"
    },
    {
        "ID": 1058,
        "Patch": " public int hashCode() {\n     return new HashCodeBuilder(17, 37).append(startTime).append(processingTime).append(queueTime)\n-      .append(responseSize).append(clientAddress).append(serverClass).append(methodName)\n-      .append(callDetails).append(param).append(regionName).append(userName).append(multiGetsCount)\n-      .append(multiMutationsCount).append(multiServiceCalls).toHashCode();\n+      .append(responseSize).append(blockBytesScanned).append(clientAddress).append(serverClass)\n+      .append(methodName).append(callDetails).append(param).append(regionName).append(userName)\n+      .append(multiGetsCount).append(multiMutationsCount).append(multiServiceCalls).toHashCode();\n   }\n ",
        "Label": "Not_Null"
    },
    {
        "ID": 1059,
        "Patch": " public String toJsonPrettyPrint() {\n   public String toString() {\n     return new ToStringBuilder(this).append(\"startTime\", startTime)\n       .append(\"processingTime\", processingTime).append(\"queueTime\", queueTime)\n-      .append(\"responseSize\", responseSize).append(\"clientAddress\", clientAddress)\n-      .append(\"serverClass\", serverClass).append(\"methodName\", methodName)\n-      .append(\"callDetails\", callDetails).append(\"param\", param).append(\"regionName\", regionName)\n-      .append(\"userName\", userName).append(\"multiGetsCount\", multiGetsCount)\n-      .append(\"multiMutationsCount\", multiMutationsCount)\n+      .append(\"responseSize\", responseSize).append(\"blockBytesScanned\", blockBytesScanned)\n+      .append(\"clientAddress\", clientAddress).append(\"serverClass\", serverClass)\n+      .append(\"methodName\", methodName).append(\"callDetails\", callDetails).append(\"param\", param)\n+      .append(\"regionName\", regionName).append(\"userName\", userName)\n+      .append(\"multiGetsCount\", multiGetsCount).append(\"multiMutationsCount\", multiMutationsCount)\n       .append(\"multiServiceCalls\", multiServiceCalls).toString();\n   }\n ",
        "Label": "Not_Null"
    },
    {
        "ID": 1050,
        "Patch": "public void run() {\n               threadGroup.setDaemon(false);\n             }\n           }\n+        } catch (NoSuchFieldException e) {\n+          LOG.debug(\"NoSuchFieldException: \" + e.getMessage()\n+            + \"; It might because your Hadoop version > 3.2.3 or 3.3.4, \"\n+            + \"See HBASE-27595 for details.\");\n         } catch (Exception e) {\n           LOG.warn(\"failed to reset thread pool timeout for FsDatasetAsyncDiskService\", e);\n         }",
        "Label": "Not_Null"
    },
    {
        "ID": 1051,
        "Patch": " final public class OnlineLogRecord extends LogEntry {\n   private final int processingTime;\n   private final int queueTime;\n   private final long responseSize;\n+  private final long blockBytesScanned;\n   private final String clientAddress;\n   private final String serverClass;\n   private final String methodName;",
        "Label": "Not_Null"
    },
    {
        "ID": 1052,
        "Patch": " public long getResponseSize() {\n     return responseSize;\n   }\n \n+  /**\n+   * Return the amount of block bytes scanned to retrieve the response cells.\n+   */\n+  public long getBlockBytesScanned() {\n+    return blockBytesScanned;\n+  }\n+\n   public String getClientAddress() {\n     return clientAddress;\n   }",
        "Label": "Not_Null"
    },
    {
        "ID": 1053,
        "Patch": " public int getMultiServiceCalls() {\n   }\n \n   private OnlineLogRecord(final long startTime, final int processingTime, final int queueTime,\n-    final long responseSize, final String clientAddress, final String serverClass,\n-    final String methodName, final String callDetails, final String param, final String regionName,\n-    final String userName, final int multiGetsCount, final int multiMutationsCount,\n-    final int multiServiceCalls) {\n+    final long responseSize, final long blockBytesScanned, final String clientAddress,\n+    final String serverClass, final String methodName, final String callDetails, final String param,\n+    final String regionName, final String userName, final int multiGetsCount,\n+    final int multiMutationsCount, final int multiServiceCalls) {\n     this.startTime = startTime;\n     this.processingTime = processingTime;\n     this.queueTime = queueTime;\n     this.responseSize = responseSize;\n+    this.blockBytesScanned = blockBytesScanned;\n     this.clientAddress = clientAddress;\n     this.serverClass = serverClass;\n     this.methodName = methodName;",
        "Label": "Not_Null"
    },
    {
        "ID": 1060,
        "Patch": " public class TestTooLargeLog {\n \n   @BeforeClass\n   public static void setUpBeforeClass() throws Exception {\n+    // Slow log needs to be enabled initially to spin up the SlowLogQueueService\n     TEST_UTIL.getConfiguration().setBoolean(HConstants.SLOW_LOG_BUFFER_ENABLED_KEY, true);\n-    TEST_UTIL.getConfiguration().setInt(\"hbase.ipc.warn.response.size\", 100);\n+    TEST_UTIL.getConfiguration().setInt(\"hbase.ipc.warn.response.size\",\n+      HConstants.DEFAULT_BLOCKSIZE / 2);\n     TEST_UTIL.startMiniCluster(1);\n     ADMIN = TEST_UTIL.getAdmin();\n   }",
        "Label": "Not_Null"
    },
    {
        "ID": 1061,
        "Patch": "public static void afterClass() throws Exception {\n+    TEST_UTIL.shutdownMiniCluster();\n+  }\n+\n   /**\n    * Tests that we can trigger based on blocks scanned, and also that we properly pass the block\n    * bytes scanned value through to the client.\n    */\n   @Test\n-  public void testLogLargeBlockBytesScanned() throws IOException, InterruptedException {\n+  public void testLogLargeBlockBytesScanned() throws IOException {\n+    // Turn off slow log buffer for initial loadTable, because we were seeing core dump\n+    // issues coming from that slow log entry. We will re-enable below.\n+    HRegionServer regionServer = TEST_UTIL.getHBaseCluster().getRegionServer(0);\n+    regionServer.getConfiguration().setBoolean(HConstants.SLOW_LOG_BUFFER_ENABLED_KEY, false);\n+    regionServer.updateConfiguration();\n+\n     byte[] family = Bytes.toBytes(\"0\");\n     Table table = TEST_UTIL.createTable(TableName.valueOf(\"testLogLargeBlockBytesScanned\"), family);\n     TEST_UTIL.loadTable(table, family);\n     TEST_UTIL.flush(table.getName());\n \n-    Set<ServerName> server =\n-      Collections.singleton(TEST_UTIL.getHBaseCluster().getRegionServer(0).getServerName());\n+    Set<ServerName> server = Collections.singleton(regionServer.getServerName());\n     Admin admin = TEST_UTIL.getAdmin();\n-    admin.clearSlowLogResponses(server);\n+\n+    // Turn on slow log so we capture large scan below\n+    regionServer.getConfiguration().setBoolean(HConstants.SLOW_LOG_BUFFER_ENABLED_KEY, true);\n+    regionServer.updateConfiguration();\n \n     Scan scan = new Scan();\n     scan.setCaching(1);",
        "Label": "Not_Null"
    },
    {
        "ID": 1062,
        "Patch": " public void testLogLargeBlockBytesScanned() throws IOException, InterruptedExcep\n       scanner.next();\n     }\n \n-    List<LogEntry> entries =\n-      admin.getLogEntries(server, \"LARGE_LOG\", ServerType.REGION_SERVER, 1, Collections.emptyMap());\n+    List<LogEntry> entries = admin.getLogEntries(server, \"LARGE_LOG\", ServerType.REGION_SERVER, 100,\n+      Collections.emptyMap());\n \n     assertEquals(1, entries.size());\n \n     OnlineLogRecord record = (OnlineLogRecord) entries.get(0);\n-    System.out.println(record.toJsonPrettyPrint());\n \n     assertTrue(\"expected \" + record.getBlockBytesScanned() + \" to be >= 100\",\n       record.getBlockBytesScanned() >= 100);",
        "Label": "Not_Null"
    },
    {
        "ID": 1063,
        "Patch": " public class TestHFileCleaner {\n \n   private static DirScanPool POOL;\n \n+  private static String MOCK_ARCHIVED_HFILE_DIR =\n+    HConstants.HFILE_ARCHIVE_DIRECTORY + \"/namespace/table/region\";\n+\n   @BeforeClass\n   public static void setupCluster() throws Exception {\n     // have to use a minidfs cluster because the localfs doesn't modify file times correctly",
        "Label": "Not_Null"
    },
    {
        "ID": 1064,
        "Patch": "public byte[] compress(byte[] valueArray, int valueOffset, int valueLength) thro\n       return compressed;\n     }\n \n-    public int decompress(InputStream in, int inLength, byte[] outArray, int outOffset,\n+    public void decompress(InputStream in, int inLength, byte[] outArray, int outOffset,\n       int outLength) throws IOException {\n \n       // Our input is a sequence of bounded byte ranges (call them segments), with",
        "Label": "Not_Null"
    },
    {
        "ID": 1065,
        "Patch": "public int decompress(InputStream in, int inLength, byte[] outArray, int outOffs\n       } else {\n         lowerIn.setDelegate(in, inLength);\n       }\n-\n-      // Caller must handle short reads.\n-      // With current Hadoop compression codecs all 'outLength' bytes are read in here, so not\n-      // an issue for now.\n-      return compressedIn.read(outArray, outOffset, outLength);\n+      if (outLength == 0) {\n+        // The BufferedInputStream will return earlier and skip reading anything if outLength == 0,\n+        // but in fact for an empty value, the compressed output still contains some metadata so the\n+        // compressed size is not 0, so here we need to manually skip inLength bytes otherwise the\n+        // next read on this stream will start from an invalid position and cause critical problem,\n+        // such as data loss when splitting wal or replicating wal.\n+        IOUtils.skipFully(in, inLength);\n+      } else {\n+        IOUtils.readFully(compressedIn, outArray, outOffset, outLength);\n+      }\n     }\n \n     public void clear() {",
        "Label": "Not_Null"
    },
    {
        "ID": 1066,
        "Patch": " public synchronized V putIfAbsent(K key, V value) {\n     if (index < 0) {\n       COWEntry<K, V> newEntry = new COWEntry<>(key, value);\n       this.holder = current.insert(-(index + 1), newEntry);\n-      return value;\n+      // putIfAbsent contract requires returning null if no previous entry exists\n+      return null;\n     }\n     return current.entries[index].getValue();\n   }",
        "Label": "Not_Null"
    },
    {
        "ID": 1067,
        "Patch": "private WriterLength getNewWriter(byte[] tableName, byte[] family, Configuration\n         HFileContextBuilder contextBuilder = new HFileContextBuilder().withCompression(compression)\n           .withDataBlockEncoding(encoding).withChecksumType(StoreUtils.getChecksumType(conf))\n           .withBytesPerCheckSum(StoreUtils.getBytesPerChecksum(conf)).withBlockSize(blockSize)\n-          .withColumnFamily(family).withTableName(tableName);\n+          .withColumnFamily(family).withTableName(tableName)\n+          .withCreateTime(EnvironmentEdgeManager.currentTime());\n \n         if (HFile.getFormatVersion(conf) >= HFile.MIN_FORMAT_VERSION_WITH_TAGS) {\n           contextBuilder.withIncludesTags(true);",
        "Label": "Not_Null"
    },
    {
        "ID": 1061,
        "Patch": "public static void afterClass() throws Exception {\n+    TEST_UTIL.shutdownMiniCluster();\n+  }\n+\n   /**\n    * Tests that we can trigger based on blocks scanned, and also that we properly pass the block\n    * bytes scanned value through to the client.\n    */\n   @Test\n-  public void testLogLargeBlockBytesScanned() throws IOException, InterruptedException {\n+  public void testLogLargeBlockBytesScanned() throws IOException {\n+    // Turn off slow log buffer for initial loadTable, because we were seeing core dump\n+    // issues coming from that slow log entry. We will re-enable below.\n+    HRegionServer regionServer = TEST_UTIL.getHBaseCluster().getRegionServer(0);\n+    regionServer.getConfiguration().setBoolean(HConstants.SLOW_LOG_BUFFER_ENABLED_KEY, false);\n+    regionServer.updateConfiguration();\n+\n     byte[] family = Bytes.toBytes(\"0\");\n     Table table = TEST_UTIL.createTable(TableName.valueOf(\"testLogLargeBlockBytesScanned\"), family);\n     TEST_UTIL.loadTable(table, family);\n     TEST_UTIL.flush(table.getName());\n \n-    Set<ServerName> server =\n-      Collections.singleton(TEST_UTIL.getHBaseCluster().getRegionServer(0).getServerName());\n+    Set<ServerName> server = Collections.singleton(regionServer.getServerName());\n     Admin admin = TEST_UTIL.getAdmin();\n-    admin.clearSlowLogResponses(server);\n+\n+    // Turn on slow log so we capture large scan below\n+    regionServer.getConfiguration().setBoolean(HConstants.SLOW_LOG_BUFFER_ENABLED_KEY, true);\n+    regionServer.updateConfiguration();\n \n     Scan scan = new Scan();\n     scan.setCaching(1);",
        "Label": "Not_Null"
    },
    {
        "ID": 1062,
        "Patch": " public void testLogLargeBlockBytesScanned() throws IOException, InterruptedExcep\n       scanner.next();\n     }\n \n-    List<LogEntry> entries =\n-      admin.getLogEntries(server, \"LARGE_LOG\", ServerType.REGION_SERVER, 1, Collections.emptyMap());\n+    List<LogEntry> entries = admin.getLogEntries(server, \"LARGE_LOG\", ServerType.REGION_SERVER, 100,\n+      Collections.emptyMap());\n \n     assertEquals(1, entries.size());\n \n     OnlineLogRecord record = (OnlineLogRecord) entries.get(0);\n-    System.out.println(record.toJsonPrettyPrint());\n \n     assertTrue(\"expected \" + record.getBlockBytesScanned() + \" to be >= 100\",\n       record.getBlockBytesScanned() >= 100);",
        "Label": "Not_Null"
    },
    {
        "ID": 1063,
        "Patch": " public class TestHFileCleaner {\n \n   private static DirScanPool POOL;\n \n+  private static String MOCK_ARCHIVED_HFILE_DIR =\n+    HConstants.HFILE_ARCHIVE_DIRECTORY + \"/namespace/table/region\";\n+\n   @BeforeClass\n   public static void setupCluster() throws Exception {\n     // have to use a minidfs cluster because the localfs doesn't modify file times correctly",
        "Label": "Not_Null"
    },
    {
        "ID": 1064,
        "Patch": "public byte[] compress(byte[] valueArray, int valueOffset, int valueLength) thro\n       return compressed;\n     }\n \n-    public int decompress(InputStream in, int inLength, byte[] outArray, int outOffset,\n+    public void decompress(InputStream in, int inLength, byte[] outArray, int outOffset,\n       int outLength) throws IOException {\n \n       // Our input is a sequence of bounded byte ranges (call them segments), with",
        "Label": "Not_Null"
    },
    {
        "ID": 1068,
        "Patch": "public HFileContextBuilder(final HFileContext hfc) {\n     this.columnFamily = hfc.getColumnFamily();\n     this.tableName = hfc.getTableName();\n     this.cellComparator = hfc.getCellComparator();\n+    this.indexBlockEncoding = hfc.getIndexBlockEncoding();\n   }\n \n   public HFileContextBuilder withHBaseCheckSum(boolean useHBaseCheckSum) {",
        "Label": "Not_Null"
    },
    {
        "ID": 1046,
        "Patch": " static StoreFileTrackerBase createForMigration(Configuration conf, String config\n       throw new IllegalArgumentException(\"Should not specify \" + configName + \" as \"\n         + Trackers.MIGRATION + \" because it can not be nested\");\n     }\n-    LOG.info(\"instantiating StoreFileTracker impl {} as {}\", tracker.getName(), configName);\n+    LOG.debug(\"instantiating StoreFileTracker impl {} as {}\", tracker.getName(), configName);\n     return ReflectionUtils.newInstance(tracker, conf, isPrimaryReplica, ctx);\n   }\n ",
        "Label": "Not_Null"
    },
    {
        "ID": 1047,
        "Patch": "public static HRegion openReadOnlyFileSystemHRegion(final Configuration conf, fi\n     return r.openHRegion(null);\n   }\n \n-  public static void warmupHRegion(final RegionInfo info, final TableDescriptor htd, final WAL wal,\n-    final Configuration conf, final RegionServerServices rsServices,\n+  public static HRegion warmupHRegion(final RegionInfo info, final TableDescriptor htd,\n+    final WAL wal, final Configuration conf, final RegionServerServices rsServices,\n     final CancelableProgressable reporter) throws IOException {\n \n     Objects.requireNonNull(info, \"RegionInfo cannot be null\");",
        "Label": "Not_Null"
    },
    {
        "ID": 1048,
        "Patch": " public void filterRowCells(List<Cell> ignored) throws IOException {\n   }\n \n   /**\n-   * Fitlers that never filter by modifying the returned List of Cells can inherit this\n+   * Filters that never filter by modifying the returned List of Cells can inherit this\n    * implementation that does nothing. {@inheritDoc}\n    */\n   @Override",
        "Label": "Not_Null"
    },
    {
        "ID": 1049,
        "Patch": "public void close() {\n       public void shipped() throws IOException {\n         this.delegate.shipped();\n       }\n+\n+      @Override\n+      public void recordBlockSize(IntConsumer blockSizeConsumer) {\n+        this.delegate.recordBlockSize(blockSizeConsumer);\n+      }\n     };\n   }\n ",
        "Label": "Not_Null"
    }
]